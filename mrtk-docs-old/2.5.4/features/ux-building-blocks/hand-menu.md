---
title: HandMenu
description: MRTK 中的手邊功能表範例場景
author: cre8ivepark
ms.author: dongpark
ms.date: 01/12/2021
keywords: Unity、HoloLens、HoloLens 2、Mixed Reality、開發、MRTK、HandMenu、
ms.openlocfilehash: 4f59f218acb569a996d18f4cd458c634807e9929
ms.sourcegitcommit: 59c91f8c70d1ad30995fba6cf862615e25e78d10
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/19/2021
ms.locfileid: "104686351"
---
# <a name="hand-menu"></a><span data-ttu-id="c6871-104">手部功能表</span><span class="sxs-lookup"><span data-stu-id="c6871-104">Hand menu</span></span>

![手形功能表 UX 範例](../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="c6871-106">手形功能表可讓使用者快速地為常用的函式顯示手動連接的 UI。</span><span class="sxs-lookup"><span data-stu-id="c6871-106">Hand menus allow users to quickly bring up hand-attached UI for frequently used functions.</span></span> <span data-ttu-id="c6871-107">若要在與其他物件互動時防止啟用錯誤，請使用右功能表提供「需要平面」和「使用注視啟用」之類的選項。</span><span class="sxs-lookup"><span data-stu-id="c6871-107">To prevent false activation while interacting with other objects, hand menu provides options such as 'Require Flat Hand' and 'Use Gaze Activation'.</span></span> <span data-ttu-id="c6871-108">建議使用這些選項來避免不必要的啟用。</span><span class="sxs-lookup"><span data-stu-id="c6871-108">It is recommended to use these options to prevent unwanted activation.</span></span>

## <a name="hand-menu-examples"></a><span data-ttu-id="c6871-109">手形功能表範例</span><span class="sxs-lookup"><span data-stu-id="c6871-109">Hand menu examples</span></span>

<span data-ttu-id="c6871-110">**HandMenuExamples。 unity** 場景位於 ``MRTK/Examples/Demos/HandTracking/Scenes`` 資料夾底下。</span><span class="sxs-lookup"><span data-stu-id="c6871-110">**HandMenuExamples.unity** scene is under ``MRTK/Examples/Demos/HandTracking/Scenes`` folder.</span></span> <span data-ttu-id="c6871-111">當該場景正在執行時，只會啟動目前選取的功能表類型。</span><span class="sxs-lookup"><span data-stu-id="c6871-111">When it is running, the scene will only activate currently selected menu type.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_ExampleScene.png" width="600px" alt="HandMenu_ExampleScene">

<span data-ttu-id="c6871-112">您可以在 [資料夾] 底下找到這些功能表 prefabs ``MRTK/Examples/Demos/HandTracking/Prefabs`` 。</span><span class="sxs-lookup"><span data-stu-id="c6871-112">You can find these hand menu prefabs under ``MRTK/Examples/Demos/HandTracking/Prefabs`` folder.</span></span>

### <a name="handmenu_small_hideonhanddrop-and-handmenu_medium_hideonhanddrop"></a><span data-ttu-id="c6871-113">HandMenu_Small_HideOnHandDrop 和 HandMenu_Medium_HideOnHandDrop</span><span class="sxs-lookup"><span data-stu-id="c6871-113">HandMenu_Small_HideOnHandDrop and HandMenu_Medium_HideOnHandDrop</span></span>

<span data-ttu-id="c6871-114">這兩個範例只會啟動和停用 MenuContent 物件，以顯示和隱藏 **OnFirstHandDetected ()** 和 **OnLastHandLost ()** 事件上的功能表。</span><span class="sxs-lookup"><span data-stu-id="c6871-114">These two examples simply activate and deactivate the MenuContent object to show and hide menu on **OnFirstHandDetected()** and **OnLastHandLost()** event.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example1.png" width="600" alt="HandMenu_ExampleScene 1">
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example2.png" width="600" alt="HandMenu_ExampleScene 2">

### <a name="handmenu_large_worldlock_on_grabandpull"></a><span data-ttu-id="c6871-115">HandMenu_Large_WorldLock_On_GrabAndPull</span><span class="sxs-lookup"><span data-stu-id="c6871-115">HandMenu_Large_WorldLock_On_GrabAndPull</span></span>

<span data-ttu-id="c6871-116">針對需要較長互動時間的更複雜功能表，建議您在功能表上進行世界鎖定。</span><span class="sxs-lookup"><span data-stu-id="c6871-116">For more complex menus that require longer interaction time, it is recommended to world-lock the menu.</span></span> <span data-ttu-id="c6871-117">在此範例中，除了啟動和停用 **OnFirstHandDetected ()** 上的 MenuContent，以及 **OnLastHandLost ()** 事件之外，使用者還可以抓取並拉出功能表。</span><span class="sxs-lookup"><span data-stu-id="c6871-117">In this example, the user can grab and pull to world-lock the menu, in addition to activating and deactivating the MenuContent on **OnFirstHandDetected()** and **OnLastHandLost()** events.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example3.png" width="600" alt="HandMenu_ExampleScene 3">

<span data-ttu-id="c6871-118">Backplate `ManipulationHandler` 可讓它 grabbable 和可移動。</span><span class="sxs-lookup"><span data-stu-id="c6871-118">Backplate's `ManipulationHandler` makes it grabbable and movable.</span></span> <span data-ttu-id="c6871-119">**在操作啟動** 事件時，SolverHandler 會停用 **UpdateSolvers** ，以世界鎖定功能表。</span><span class="sxs-lookup"><span data-stu-id="c6871-119">**On Manipulation Started** event, **SolverHandler.UpdateSolvers** is deactivated to world-lock the menu.</span></span> <span data-ttu-id="c6871-120">此外，它也會顯示 [ **關閉] 按鈕** ，讓使用者在工作完成時關閉功能表。</span><span class="sxs-lookup"><span data-stu-id="c6871-120">Additionally, it shows the **Close button** to allow the user to close the menu when the task is finished.</span></span> <span data-ttu-id="c6871-121">**在操作結束事件時** ，它會呼叫 **HandConstraintPalmUp** ，以允許使用者藉由產生並查看掌上，讓功能表回到手邊。</span><span class="sxs-lookup"><span data-stu-id="c6871-121">**On Manipulation Ended** event, it calls **HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine** to allow the user bring the menu back to hand by raising and looking at the palm.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example4.png" width="600" alt="HandMenu_ExampleScene 4">

<span data-ttu-id="c6871-122">[**關閉**] 按鈕會重新開機 **SolverHandler，UpdateSolvers** 並隱藏 **MenuContent**。</span><span class="sxs-lookup"><span data-stu-id="c6871-122">**Close** button reactivates **SolverHandler.UpdateSolvers** and hide the **MenuContent**.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example5.png" alt="HandMenu_ExampleScene 5">

### <a name="handmenu_large_autoworldlock_on_handdrop"></a><span data-ttu-id="c6871-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span><span class="sxs-lookup"><span data-stu-id="c6871-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span></span>

<span data-ttu-id="c6871-124">此範例類似于 HandMenu_Large_WorldLock_On_GrabAndPull。</span><span class="sxs-lookup"><span data-stu-id="c6871-124">This example is similar to HandMenu_Large_WorldLock_On_GrabAndPull.</span></span> <span data-ttu-id="c6871-125">唯一的不同之處在于功能表會自動放在手上。</span><span class="sxs-lookup"><span data-stu-id="c6871-125">The only difference is that the menu will be automatically world-locked on hand drop.</span></span> <span data-ttu-id="c6871-126">這是藉由單純不要隱藏 MenuContent on **OnLastHandLost ()** 事件來完成。</span><span class="sxs-lookup"><span data-stu-id="c6871-126">This is done by simply not hiding the MenuContent on **OnLastHandLost()** event.</span></span> <span data-ttu-id="c6871-127">抓取 & 提取行為與 HandMenu_Large_WorldLock_On_GrabAndPull 範例相同。</span><span class="sxs-lookup"><span data-stu-id="c6871-127">Grab & pull behavior is same as HandMenu_Large_WorldLock_On_GrabAndPull example.</span></span>

## <a name="scripts"></a><span data-ttu-id="c6871-128">指令碼</span><span class="sxs-lookup"><span data-stu-id="c6871-128">Scripts</span></span>

<span data-ttu-id="c6871-129">此 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 行為提供的規劃求解會將追蹤的物件限制為可安全的 (，例如，手動 UI、功能表等) 。</span><span class="sxs-lookup"><span data-stu-id="c6871-129">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="c6871-130">安全區域會被視為不會與手相交的區域。</span><span class="sxs-lookup"><span data-stu-id="c6871-130">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="c6871-131">[`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint)另外也包含了呼叫的衍生類別 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) ，以示範當掌上有使用者時啟動規劃求解追蹤物件的常見行為。</span><span class="sxs-lookup"><span data-stu-id="c6871-131">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="c6871-132">如需其他檔，請參閱每個屬性可用的工具提示 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 。</span><span class="sxs-lookup"><span data-stu-id="c6871-132">Please see the tool tips available for each [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) property for additional documentation.</span></span> <span data-ttu-id="c6871-133">以下會更詳細地定義幾個屬性。</span><span class="sxs-lookup"><span data-stu-id="c6871-133">A few properties are defined in more detail below.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintPalmUp.png" width="450" alt="HandMenu_ExampleScene Palm up">

* <span data-ttu-id="c6871-134">**安全區域**：安全區域會指定要限制內容的位置。</span><span class="sxs-lookup"><span data-stu-id="c6871-134">**Safe Zone**: The safe zone specifies where on the hand to constrain content.</span></span> <span data-ttu-id="c6871-135">建議將內容放在 Ulnar 端，以避免與手邊和改進的互動品質重迭。</span><span class="sxs-lookup"><span data-stu-id="c6871-135">It is recommended that content be placed on the Ulnar Side to avoid overlap with the hand and improved interaction quality.</span></span> <span data-ttu-id="c6871-136">安全區域的計算方式是將手投射到平面的平面上，並以圍繞手的周框方塊 raycasting。</span><span class="sxs-lookup"><span data-stu-id="c6871-136">Safe zones are calculated by taking the hands orientation projected into a plane orthogonal to the camera's view and raycasting against a bounding box around the hands.</span></span> <span data-ttu-id="c6871-137">安全區域的定義可搭配使用， [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 但也適用于其他控制器類型。</span><span class="sxs-lookup"><span data-stu-id="c6871-137">Safe zones are defined to work with [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with other controller types.</span></span> <span data-ttu-id="c6871-138">建議您探索每個安全區域代表不同控制器類型的內容。</span><span class="sxs-lookup"><span data-stu-id="c6871-138">It is recommended to explore what each safe zone represents on different controller types.</span></span>

* <span data-ttu-id="c6871-139">在 **面對相機之前接手** 使用這個活動時，將會在功能表充分配合臉部的位置之後，進行規劃，並在該時間點面對攝影機。</span><span class="sxs-lookup"><span data-stu-id="c6871-139">**Follow Hand Until Facing Camera** With this active, solver will follow hand rotation until the menu is sufficiently aligned with the gaze, at which point it faces the camera.</span></span> <span data-ttu-id="c6871-140">這項作業的運作方式是將 HandConstraintSolver 中的 SolverRotationBehavior，從 LookAtTrackedObject 變更為 LookAtMainCamera，因為 GazeAlignment 角度與規劃求解會有所不同。</span><span class="sxs-lookup"><span data-stu-id="c6871-140">This works by changing the SolverRotationBehavior in the HandConstraintSolver, from LookAtTrackedObject to LookAtMainCamera as the GazeAlignment angle with the solver varies.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintSafeZones.png" width="450" alt="HandMenu Safe Zones">

* <span data-ttu-id="c6871-141">**啟用事件**：目前 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 觸發四項啟用事件。</span><span class="sxs-lookup"><span data-stu-id="c6871-141">**Activation Events**: Currently the [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) triggers four activation events.</span></span> <span data-ttu-id="c6871-142">這些事件可用於許多不同的組合以建立獨特 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 的行為，請參閱下的 HandBasedMenuExample 場景， `MRTK/Examples/Demos/HandTracking/Scenes/` 以取得這些行為的範例。</span><span class="sxs-lookup"><span data-stu-id="c6871-142">These events can be used in many different combinations to create unique [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behaviors, please see the HandBasedMenuExample scene under `MRTK/Examples/Demos/HandTracking/Scenes/` for examples of these behaviors.</span></span>

  * <span data-ttu-id="c6871-143">*OnHandActivate*：當手符合 IsHandActive 方法時觸發。</span><span class="sxs-lookup"><span data-stu-id="c6871-143">*OnHandActivate*: triggers when a hand satisfies the IsHandActive method.</span></span>
  * <span data-ttu-id="c6871-144">*OnHandDeactivate*：當不再滿足 IsHandActive 方法時，就會觸發。</span><span class="sxs-lookup"><span data-stu-id="c6871-144">*OnHandDeactivate*: triggers when the IsHandActive method is no longer satisfied.</span></span>
  * <span data-ttu-id="c6871-145">*OnFirstHandDetected*：當手動追蹤狀態從沒有實際的視圖變更為第一次觀看時，就會發生此情況。</span><span class="sxs-lookup"><span data-stu-id="c6871-145">*OnFirstHandDetected*: occurs when the hand tracking state changes from no hands in view, to the first hand in view.</span></span>
  * <span data-ttu-id="c6871-146">*OnLastHandLost*：當手動追蹤狀態從至少一個手上變更為沒有實際畫面時，就會發生此情況。</span><span class="sxs-lookup"><span data-stu-id="c6871-146">*OnLastHandLost*: occurs when the hand tracking state changes from at least one hand in view, to no hands in view.</span></span>

* <span data-ttu-id="c6871-147">**規劃求解啟用/停用邏輯**：目前針對啟用和停用邏輯的建議 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 是透過使用 SolverHandler 的 UpdateSolver 值來執行，而不是停用/啟用物件。</span><span class="sxs-lookup"><span data-stu-id="c6871-147">**Solver Activation/Deactivation Logic**: Currently the recommendation for activating and deactivating [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) logic is to do so through the use of the SolverHandler's UpdateSolver value, rather than by disabling/enabling the object.</span></span> <span data-ttu-id="c6871-148">您可以透過在附加功能表的 ManipulationHandler 「OnManipulationStarted/結束」事件之後所觸發的以編輯器為基礎的勾點，在範例場景中看到這種情況。</span><span class="sxs-lookup"><span data-stu-id="c6871-148">This can be seen in the example scene through the editor-based hooks triggered after the attached menu's ManipulationHandler "OnManipulationStarted/Ended" events.</span></span>

  * <span data-ttu-id="c6871-149">*停止手形條件約束邏輯*：嘗試設定手限制物件以停止 (以及不要執行啟用/停用邏輯) 時，請將 UpdateSolver 設定為 False，而不是停用 HandConstraintPalmUp。</span><span class="sxs-lookup"><span data-stu-id="c6871-149">*Stopping the hand-constraint logic*: When trying to set the hand constrained object to stop (as well as not run the activation/deactivation logic), set UpdateSolver to False rather than disabling HandConstraintPalmUp.</span></span>
    * <span data-ttu-id="c6871-150">如果您想要啟用以注視為基礎的 (或甚至是非等式的) 重新附加邏輯，則會接著呼叫 HandConstraintPalmUp. StartWorldLockReattachCheckCoroutine () 函數。</span><span class="sxs-lookup"><span data-stu-id="c6871-150">If you want to enable the gaze-based (or even non-gaze-based) Reattach logic, this is then followed by calling the HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine() function.</span></span> <span data-ttu-id="c6871-151">這會觸發協同程式，然後繼續檢查是否符合 "IsValidController" 準則，並在 (或停用物件時將 UpdateSolver 設定為 True) </span><span class="sxs-lookup"><span data-stu-id="c6871-151">This will trigger a coroutine that then continues to check if the "IsValidController" criteria is met and will set UpdateSolver to True once it is (or the object is disabled)</span></span>
  * <span data-ttu-id="c6871-152">*啟動手形條件約束邏輯*：當您嘗試設定手限制物件，使其根據是否符合啟動準則)  (，請將 SolverHandler 的 UpdateSolver 設定為 true。</span><span class="sxs-lookup"><span data-stu-id="c6871-152">*Starting the hand-constraint logic*: When trying to set the hand constrained object to start following your hand again (based on whether it meets the activation criteria), set the SolverHandler's UpdateSolver to true.</span></span>

* <span data-ttu-id="c6871-153">重新 **附加邏輯**：目前 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 可以自動將目標物件重新附加至追蹤點，而不論 SolverHandler 的 UpdateSolver 是否為 True。</span><span class="sxs-lookup"><span data-stu-id="c6871-153">**Reattach Logic**: Currently the [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is able to automatically reattach the target object to the tracked point, regardless of whether the SolverHandler's UpdateSolver is True or not.</span></span> <span data-ttu-id="c6871-154">這是透過呼叫 HandConstraintPalmUp 的 StartWorldLockReattachCheckCoroutine () 函式來完成 (，在這種情況下，會將 SolverHandler 的 UpdateSolver 有效地設定為 False) 。</span><span class="sxs-lookup"><span data-stu-id="c6871-154">This is done through calling the HandConstraintPalmUp's StartWorldLockReattachCheckCoroutine() function, after it's been world-locked (which in this case, is effectively setting the SolverHandler's UpdateSolver to False).</span></span>

## <a name="see-also"></a><span data-ttu-id="c6871-155">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c6871-155">See also</span></span>

* [<span data-ttu-id="c6871-156">按鈕</span><span class="sxs-lookup"><span data-stu-id="c6871-156">Button</span></span>](button.md)
* [<span data-ttu-id="c6871-157">近端功能表</span><span class="sxs-lookup"><span data-stu-id="c6871-157">Near Menu</span></span>](near-menu.md)
