---
title: BreakingChanges
description: 有關 MRTK 中之重大變更的原則。
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity、HoloLens、HoloLens 2、Mixed Reality、開發、MRTK、
ms.openlocfilehash: 264be443544b51f453ed0001945b488698fb46f9
ms.sourcegitcommit: 59c91f8c70d1ad30995fba6cf862615e25e78d10
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/19/2021
ms.locfileid: "104684721"
---
# <a name="breaking-changes"></a><span data-ttu-id="fa170-104">重大變更</span><span class="sxs-lookup"><span data-stu-id="fa170-104">Breaking changes</span></span>

<span data-ttu-id="fa170-105">MRTK 的取用者相依于擁有穩定的發行對發行 API 介面，讓它們可以在不需要每次大量變更的情況下，取得 MRTK 的更新。</span><span class="sxs-lookup"><span data-stu-id="fa170-105">Consumers of the MRTK depend on having a stable release-to-release API surface, so that they can take updates to the MRTK without having large breaking changes each time.</span></span>

<span data-ttu-id="fa170-106">此頁面描述 MRTK 中有關重大變更的目前原則，以及一些更長期的目標，以瞭解如何更妥善地管理中斷變更，以及能夠對程式碼進行正確的長期技術變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-106">This page describes our current policy regarding breaking changes in the MRTK, along with some longer term goals around how we can better manage the tradeoff between keeping breaking changes low and being able to make the right long term technical changes to the code.</span></span>

## <a name="what-is-a-breaking-change"></a><span data-ttu-id="fa170-107">什麼是重大變更？</span><span class="sxs-lookup"><span data-stu-id="fa170-107">What is a breaking change?</span></span>

<span data-ttu-id="fa170-108">如果變更符合[清單 a](#list-a)中的任何條件，並且符合[清單 B](#list-b)中的所有條件，則變更為重大變更</span><span class="sxs-lookup"><span data-stu-id="fa170-108">A change is a breaking change if it satisfies any of the conditions in the [List A](#list-a) AND satisfies all of the conditions in [list B](#list-b)</span></span>

### <a name="list-a"></a><span data-ttu-id="fa170-109">列出</span><span class="sxs-lookup"><span data-stu-id="fa170-109">List A</span></span>

- <span data-ttu-id="fa170-110">新增、移除或更新任何介面的任何成員或函數， (或移除/重新命名整個介面) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-110">The addition, removal, or update of any member or function of any interface (or removal/rename of the entire interface).</span></span>
- <span data-ttu-id="fa170-111">移除、更新 (變更類型/定義，使其成為任何受保護或公用成員或類別功能的私用或內部) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-111">The removal, update (changing type/definition, making private or internal) of any protected or public member or function of class.</span></span> <span data-ttu-id="fa170-112"> (或移除/重新命名整個類別) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-112">(or removal/rename of the entire class).</span></span>
- <span data-ttu-id="fa170-113">類別所引發的事件順序變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-113">The change in the order of events fired by a class.</span></span>
- <span data-ttu-id="fa170-114">重新命名任何私用 SerializedField (沒有對應的 FormerlySerializedAs 標籤) 或 ScriptableObject 上的公用屬性 (特別是對設定檔) 的變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-114">The rename of any private SerializedField (without a corresponding FormerlySerializedAs tag) or public property on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="fa170-115">變更 ScriptableObject 上欄位的類型 (特別是) 設定檔的變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-115">Changing the type of a field on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="fa170-116">對任何類別或介面的命名空間或 asmdefs 進行更新。</span><span class="sxs-lookup"><span data-stu-id="fa170-116">Updates to the namespace or asmdefs of any class or interface.</span></span>
- <span data-ttu-id="fa170-117">移除預製專案最上層物件上的任何預製專案或移除腳本。</span><span class="sxs-lookup"><span data-stu-id="fa170-117">Removal of any prefab or removal of a script on the top level object of a prefab.</span></span>

### <a name="list-b"></a><span data-ttu-id="fa170-118">清單 B</span><span class="sxs-lookup"><span data-stu-id="fa170-118">List B</span></span>

- <span data-ttu-id="fa170-119">有問題的資產是在基礎封裝中 (也就是在下列其中一個資料夾中) ：</span><span class="sxs-lookup"><span data-stu-id="fa170-119">The asset in question is in the foundation package (i.e. it's in one of the following folders):</span></span>

  - <span data-ttu-id="fa170-120">MRTK/核心</span><span class="sxs-lookup"><span data-stu-id="fa170-120">MRTK/Core</span></span>
  - <span data-ttu-id="fa170-121">MRTK/Providers/</span><span class="sxs-lookup"><span data-stu-id="fa170-121">MRTK/Providers/</span></span>
  - <span data-ttu-id="fa170-122">MRTK/Services/</span><span class="sxs-lookup"><span data-stu-id="fa170-122">MRTK/Services/</span></span>
  - <span data-ttu-id="fa170-123">MRTK/SDK/</span><span class="sxs-lookup"><span data-stu-id="fa170-123">MRTK/SDK/</span></span>
  - <span data-ttu-id="fa170-124">MRTK/擴充功能</span><span class="sxs-lookup"><span data-stu-id="fa170-124">MRTK/Extensions</span></span>

- <span data-ttu-id="fa170-125">有問題的資產不屬於實驗命名空間。</span><span class="sxs-lookup"><span data-stu-id="fa170-125">The asset in question does not belong to the experimental namespace.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="fa170-126">任何位於範例套件中的資產 (也就是 MRTK/範例/資料夾) 的一部分隨時可能變更，因為資產的設計目的是要將取用者複製和查看為「參考實施」，但不屬於核心的 Api 和資產集。</span><span class="sxs-lookup"><span data-stu-id="fa170-126">Any asset that sits in the examples package (i.e. part of the MRTK/Examples/ folder) is subject to change at any time, as assets there are designed to be copied and viewed by consumers as 'reference implementations' but are not part of the core set of APIs and assets.</span></span> <span data-ttu-id="fa170-127">實驗命名空間中的資產 (（或更多）通常是標示為實驗性) 的功能，就是在完成所有到期的工作之前發佈的專案 (例如測試、UX 反復專案、檔) ，而且會提早發行以取得意見反應。</span><span class="sxs-lookup"><span data-stu-id="fa170-127">Assets in the experimental namespace (or more generally, features labelled as experimental) are ones that get published before all due diligence has been done (i.e. tests, UX iteration, documentation) and is published early to get feedback sooner.</span></span>  <span data-ttu-id="fa170-128">不過，因為它們沒有測試和檔，而且因為我們可能尚未答對所有互動和設計，所以我們會在 (公開的情況下發布這些互動和設計，也就是修改、完全移除等) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-128">However, because they don't have tests and documentation, and because we likely haven't nailed down all of the interactions and designs, we publish them in a state where the public should assume that they can and will change (i.e. be modified, completely removed, etc).</span></span>
>
> <span data-ttu-id="fa170-129">如需詳細資訊，請參閱 [實驗性功能](../contributing/experimental-features.md) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-129">See [Experimental features](../contributing/experimental-features.md) for more information.</span></span>

<span data-ttu-id="fa170-130">由於重大變更的介面區非常龐大，因此請務必注意，有一項絕對規則會指出「沒有重大變更」是不可能的，因為可能會有一些問題，只有在有重大變更的情況下，才能以清楚了的方式加以修正。</span><span class="sxs-lookup"><span data-stu-id="fa170-130">As the surface area for breaking changes is very large, it's important to note that having an absolute rule that says "no breaking changes" would be impossible - there may be issues that can only be fixed in a sane way by having a breaking change.</span></span> <span data-ttu-id="fa170-131">若要以另一種方式進行，我們可以真正沒有任何重大變更的唯一方法就是完全沒有變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-131">To put another way, the only way we could really have "no breaking changes" is to have no changes at all.</span></span>

<span data-ttu-id="fa170-132">我們的長期原則是避免在可能的情況下進行重大變更，而且只有在變更會累積大量客戶或架構長期的價值時才這樣做。</span><span class="sxs-lookup"><span data-stu-id="fa170-132">Our standing policy is to avoid making breaking changes if possible, and only do so if the change would accrue significant customer or framework long term value.</span></span>

## <a name="what-to-do-about-breaking-changes"></a><span data-ttu-id="fa170-133">重大變更的用途</span><span class="sxs-lookup"><span data-stu-id="fa170-133">What to do about breaking changes</span></span>

<span data-ttu-id="fa170-134">如果有可能在沒有重大變更的情況下完成某項作業，而且未危及功能的長期結構和可行性，請不要進行中斷性變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-134">If it is possible to accomplish something without a breaking change and without compromising the long term structure and viability of the feature, don't do the breaking change.</span></span> <span data-ttu-id="fa170-135">如果沒有其他方法，則目前的原則是評估每個個別的重大變更，以瞭解進行變更的好處是否超過吸收變更的取用者成本。</span><span class="sxs-lookup"><span data-stu-id="fa170-135">If there is no other way, the current policy is to evaluate each individual breaking change, to understand if the benefit from taking the change outweighs the cost to the consumer of absorbing the change.</span></span> <span data-ttu-id="fa170-136">討論有哪些值得進行的工作，以及在 PR 或問題討論方面通常不會發生什麼事。</span><span class="sxs-lookup"><span data-stu-id="fa170-136">Debate about what is worth doing and what isn't will generally take place on the PR or issue discussion itself.</span></span>

<span data-ttu-id="fa170-137">這裡可能會有幾個值區：</span><span class="sxs-lookup"><span data-stu-id="fa170-137">What can happen here falls into several buckets:</span></span>

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a><span data-ttu-id="fa170-138">中斷性變更增加了價值，但無法以不中斷的方式寫入</span><span class="sxs-lookup"><span data-stu-id="fa170-138">The breaking change adds value but could be written in a way that isn't breaking</span></span>

<span data-ttu-id="fa170-139">例如， [此 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 新增了一項新功能，其一開始是以已中斷的方式修改現有的介面，但接著會在功能被視為本身介面的地方重寫。</span><span class="sxs-lookup"><span data-stu-id="fa170-139">For example, [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) added a new feature that was initially written in a way that was breaking - it modified an existing interface - but was then rewritten where the feature was broken out as its own interface.</span></span> <span data-ttu-id="fa170-140">這通常是最可能的結果。</span><span class="sxs-lookup"><span data-stu-id="fa170-140">This is generally the best possible outcome.</span></span> <span data-ttu-id="fa170-141">如果這樣做會危及功能的長期可行性或結構，請不要嘗試強制變更成為不中斷的表單。</span><span class="sxs-lookup"><span data-stu-id="fa170-141">Do not try to force a change into a non-breaking form if doing so would compromise the long term viability or structure of the feature.</span></span>

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a><span data-ttu-id="fa170-142">中斷性變更為客戶增加了足夠的價值，</span><span class="sxs-lookup"><span data-stu-id="fa170-142">The breaking change adds sufficient value to the customer that it's worth doing</span></span>

<span data-ttu-id="fa170-143">記錄重大變更的內容，並提供最佳的緩和措施 (例如，有關如何遷移或更好的工具將自動遷移至客戶) 的規範步驟。</span><span class="sxs-lookup"><span data-stu-id="fa170-143">Document what the breaking changes are and provide the best possible mitigation (i.e. prescriptive steps on how to migrate, or better yet tooling that will automatically migrate for the customer).</span></span> <span data-ttu-id="fa170-144">每個版本可能會包含一些重大變更，這些變更應該一律記錄在 [此 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)中的檔。</span><span class="sxs-lookup"><span data-stu-id="fa170-144">Each release may contain a small amount of changes that are breaking - these should always be documented in docs as was done in [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858).</span></span> <span data-ttu-id="fa170-145">如果已經有2.x → 2.x +1 x + 1 的遷移指南，請在該檔中新增指示或工具。如果不存在，請加以建立。</span><span class="sxs-lookup"><span data-stu-id="fa170-145">If there already is a 2.x.x→2.x+1.x+1 migration guide, then add instructions or tooling to that doc. If it doesn't exist, create it.</span></span>

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a><span data-ttu-id="fa170-146">中斷性變更增加了價值，但客戶的難題會太高</span><span class="sxs-lookup"><span data-stu-id="fa170-146">The breaking change adds value but the customer pain would be too high</span></span>

<span data-ttu-id="fa170-147">並非所有類型的中斷性變更都是相等的，有些則會根據我們的經驗和客戶體驗，更令人頭痛。</span><span class="sxs-lookup"><span data-stu-id="fa170-147">Not all types of breaking changes are created equal - some are significantly more painful that others, based on our experience and based on customer experiences.</span></span> <span data-ttu-id="fa170-148">例如，對介面的變更可能很麻煩，但如果中斷性變更是客戶不太可能在過去 (診斷視覺效果系統來擴充/執行，例如) ，則實際成本可能會低到任何東西。</span><span class="sxs-lookup"><span data-stu-id="fa170-148">For example, changes to interfaces may be painful, but if the breaking change is one in which a customer is unlikely to have extended/implemented in the past (the diagnostic visualization system, for example), then the actual cost is probably low to nothing.</span></span> <span data-ttu-id="fa170-149">但是，如果變更是 ScriptableObject 上欄位的類型 (例如，在 MRTK) 的其中一個核心設定檔上，這可能會導致大量客戶的難題。</span><span class="sxs-lookup"><span data-stu-id="fa170-149">However, if the change is the type of a field on a ScriptableObject (for example, on one of the core profiles of the MRTK), this is likely to cause massive customer pain.</span></span> <span data-ttu-id="fa170-150">客戶已複製預設設定檔，合併/更新設定檔可能很難手動執行 (也就是在合併時間) 的文字編輯器中，重新複製預設設定檔，並以手動方式重新設定所有專案，很可能會導致難以進行回歸。</span><span class="sxs-lookup"><span data-stu-id="fa170-150">Customers have already cloned the default profile, merging/updating profiles can be extremely hard to do manually (i.e. via a text editor during merge time), and re-copying the default profile and reconfiguring everything by hand is extremely likely to lead to hard to debug regressions.</span></span>

<span data-ttu-id="fa170-151">這些變更必須放回貨架上，直到存在可大幅中斷變更 (的分支，並提供可讓客戶有理由升級) 的重要價值。</span><span class="sxs-lookup"><span data-stu-id="fa170-151">These changes we have to put back onto the shelf until a branch exists that will allow significantly breaking changes (along with significant value that will give customers a reason to upgrade).</span></span> <span data-ttu-id="fa170-152">這類分支目前不存在。</span><span class="sxs-lookup"><span data-stu-id="fa170-152">Such a branch doesn't currently exist.</span></span> <span data-ttu-id="fa170-153">在我們未來的反復專案規劃會議中，我們將探討一組變更/問題，也就是「過於中斷」的變更/問題，看看我們是否已達到重大的品質，讓您能夠合理地一次執行一組變更。</span><span class="sxs-lookup"><span data-stu-id="fa170-153">In our future iteration planning meetings, we will review the set of changes/issues that were 'too breaking' to see if we reached a critical mass to make it reasonable to pursue a set of changes all at once.</span></span> <span data-ttu-id="fa170-154">請注意，因為我們擁有有限的工程資源，所以啟動「允許所有專案」的分支不會有任何問題，因此我們必須在這兩個專案之間分割測試與驗證。</span><span class="sxs-lookup"><span data-stu-id="fa170-154">Note that it's dangerous to spin up a "everything is allowed" branch without due diligence being done because of the limited engineering resources we have, and the fact that we'd have to split testing and validation across those two.</span></span> <span data-ttu-id="fa170-155">這類分支的開始和結束日期必須是清楚的用途，且會有妥善傳達的開始和結束日期。</span><span class="sxs-lookup"><span data-stu-id="fa170-155">There needs to be a clear purpose and well-communicated start and end date of such a branch when it exists.</span></span>

## <a name="long-term-management-of-breaking-changes"></a><span data-ttu-id="fa170-156">重大變更的長期管理</span><span class="sxs-lookup"><span data-stu-id="fa170-156">Long term management of breaking changes</span></span>

<span data-ttu-id="fa170-157">長期而言，我們應該在 [清單 B](#list-b)中增加一組條件，藉以減少重大變更的範圍。繼續進行 [清單 A](#list-a) 中的一組作業，在技術上，我們認為是「公用 API 介面」的一組檔案和資產，一律會中斷。</span><span class="sxs-lookup"><span data-stu-id="fa170-157">In the long term, we should seek to reduce the scope of what is a breaking change by increasing the set of conditions in [List B](#list-b). Going forward the set of things in [List A](#list-a) will always technically be breaking for the set of files and assets that we deem to be in the "public API surface."</span></span> <span data-ttu-id="fa170-158">我們可以更自由地進行反覆運算 (也就是變更內部實作為詳細資料，以便在多個類別之間更輕鬆地重構和共用程式碼，甚至) ，更明確地說，程式碼的哪些部分是官方介面，而不是實作為詳細資料。</span><span class="sxs-lookup"><span data-stu-id="fa170-158">The way that we can get a little more freedom for iteration (i.e. changing up the internal implementation details, allowing for easier refactoring and sharing of code between multiple classes, etc) is to be more explicit about which portions of the code are official surface, rather than implementation detail.</span></span>

<span data-ttu-id="fa170-159">我們已經完成的其中一件事，就是介紹「實驗性」功能 (它在實驗命名空間中的概念，它可能不會有測試/檔，而且會公開 proclaimed 至存在，但可能會移除並更新，而不會發生警告) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-159">One thing we've already done is introduce the concept of an "experimental" feature (it belongs in the experimental namespace, it may not have tests/documentation, and is publicly proclaimed to exist but may be removed and updated without warning).</span></span> <span data-ttu-id="fa170-160">這可讓您更快速地新增新功能來取得較早的意見反應，但不會立即與 API 介面 (的關聯，因為我們可能尚未完全考慮 API 介面) 。</span><span class="sxs-lookup"><span data-stu-id="fa170-160">This has given has freedom to add new features sooner to get earlier feedback, but not be immediately tied to its API surface (because we may not have fully thought out the API surface).</span></span>

### <a name="other-examples-of-things-that-could-help-in-the-future"></a><span data-ttu-id="fa170-161">未來可能會有説明的其他專案範例</span><span class="sxs-lookup"><span data-stu-id="fa170-161">Other examples of things that could help in the future</span></span>

- <span data-ttu-id="fa170-162">[Internal 關鍵字](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/internal)的使用方式。</span><span class="sxs-lookup"><span data-stu-id="fa170-162">Usage of the [internal keyword](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/internal).</span></span>
  <span data-ttu-id="fa170-163">如此一來，我們就可以在自己的元件內擁有共用程式碼 (以便減少程式碼重複) ，而不需要對外部取用者公開任何東西。</span><span class="sxs-lookup"><span data-stu-id="fa170-163">This would allow for us to have shared code within our own assemblies (for reducing code duplication) without making things public to external consumers.</span></span>
- <span data-ttu-id="fa170-164">建立「內部」命名空間 (例如) MixedReality，我們會在其中公開記載該內部命名空間內所含的任何事物，隨時可能會變更，並可加以移除等等。這與 c + + 標頭程式庫使用：：內部命名空間來隱藏其實作為詳細資料的方式類似。</span><span class="sxs-lookup"><span data-stu-id="fa170-164">Creation of an "internal" namespace (i.e. Microsoft.MixedReality.Toolkit.Internal.Utilities), where we publicly document that anything contained within that internal namespace is subject to change at anytime and could be removed, etc. This is similar to how C++ header libraries will make use of ::internal namespaces to hide their implementation details.</span></span>
