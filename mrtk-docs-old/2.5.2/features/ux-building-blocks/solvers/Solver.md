---
title: Solver
description: MRTK 中的解析器總覽
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
keywords: Unity、HoloLens、HoloLens 2、Mixed Reality、開發、MRTK、解析器、
ms.openlocfilehash: 8d1b5aa94379e54444e42e335265a2f7cbf8ea59
ms.sourcegitcommit: 59c91f8c70d1ad30995fba6cf862615e25e78d10
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/19/2021
ms.locfileid: "104686651"
---
# <a name="solvers"></a><span data-ttu-id="1a67d-104">解算器</span><span class="sxs-lookup"><span data-stu-id="1a67d-104">Solvers</span></span>

![規劃主](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="1a67d-106">解析器是一種元件，可根據預先定義的演算法，協助計算物件的位置 & 方向。</span><span class="sxs-lookup"><span data-stu-id="1a67d-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefine algorithm.</span></span> <span data-ttu-id="1a67d-107">例如，可能會將物件放在使用者的注視 raycast 目前點擊的表面上。</span><span class="sxs-lookup"><span data-stu-id="1a67d-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>  

<span data-ttu-id="1a67d-108">此外，「規劃求解」系統會以決定性的方式定義這些轉換計算的作業順序，因為沒有可靠的方式可以指定元件的更新順序給 Unity。</span><span class="sxs-lookup"><span data-stu-id="1a67d-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="1a67d-109">解析器提供一系列行為，以將物件附加至其他物件或系統。</span><span class="sxs-lookup"><span data-stu-id="1a67d-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="1a67d-110">另一個範例是標記物件，該物件會停留在使用者 (根據相機) 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="1a67d-111">規劃求解也可以附加至控制器和物件，以沿著控制器來建立物件標記。</span><span class="sxs-lookup"><span data-stu-id="1a67d-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="1a67d-112">所有的解析器都可以安全地堆疊，例如標籤-沿著行為 + surface 磁性 + 動力。</span><span class="sxs-lookup"><span data-stu-id="1a67d-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="1a67d-113">如何使用規劃求解</span><span class="sxs-lookup"><span data-stu-id="1a67d-113">How to use a solver</span></span>

<span data-ttu-id="1a67d-114">規劃求解系統包含三種腳本類別：</span><span class="sxs-lookup"><span data-stu-id="1a67d-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="1a67d-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver)：所有解析器衍生自的基底抽象類別。</span><span class="sxs-lookup"><span data-stu-id="1a67d-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="1a67d-116">它提供狀態追蹤、平滑參數和實行、自動規劃求解系統整合，以及更新順序。</span><span class="sxs-lookup"><span data-stu-id="1a67d-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="1a67d-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)：設定要追蹤的參考物件 (例如：主要相機轉換、手光線等 ) 、處理收集求解元件的程式，並以正確的循序執行更新。</span><span class="sxs-lookup"><span data-stu-id="1a67d-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="1a67d-118">第三個類別是規劃求解本身。</span><span class="sxs-lookup"><span data-stu-id="1a67d-118">The third category is the solver itself.</span></span> <span data-ttu-id="1a67d-119">下列解析器提供基本行為的建立區塊：</span><span class="sxs-lookup"><span data-stu-id="1a67d-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="1a67d-120">[`Orbital`](#orbital)：鎖定至指定的位置，以及從參考的物件位移。</span><span class="sxs-lookup"><span data-stu-id="1a67d-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="1a67d-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize)：調整以維持相對於參考物件之視圖的固定大小。</span><span class="sxs-lookup"><span data-stu-id="1a67d-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="1a67d-122">[`RadialView`](#radialview)：將物件保留在被參考物件轉換的視圖錐形內。</span><span class="sxs-lookup"><span data-stu-id="1a67d-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="1a67d-123">[`SurfaceMagnetism`](#surfacemagnetism)：將光線轉換成世界中的表面，並將物件對齊該介面。</span><span class="sxs-lookup"><span data-stu-id="1a67d-123">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="1a67d-124">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum)：套用加速度/速度/摩擦，以模擬其他解析器/元件正在移動之物件的動力和 springiness。</span><span class="sxs-lookup"><span data-stu-id="1a67d-124">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="1a67d-125">[`InBetween`](#inbetween)：將物件保留在兩個追蹤的物件之間。</span><span class="sxs-lookup"><span data-stu-id="1a67d-125">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="1a67d-126">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup)：限制物件，使其在不與 GameObject 的區域中的實際操作。</span><span class="sxs-lookup"><span data-stu-id="1a67d-126">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="1a67d-127">適用于手動限制的互動式內容，例如功能表等。這項規劃的目標是要與 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 搭配使用，但也可以搭配 [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController)使用。</span><span class="sxs-lookup"><span data-stu-id="1a67d-127">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="1a67d-128">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup)：衍生自 HandConstraint，但會包含邏輯，以測試 palm 是否會在啟用前對使用者進行測試。</span><span class="sxs-lookup"><span data-stu-id="1a67d-128">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="1a67d-129">此規劃求解只適用于 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 控制器，而其他控制器類型則此規劃求解的行為就像其基類一樣。</span><span class="sxs-lookup"><span data-stu-id="1a67d-129">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="1a67d-130">若要使用「規劃求解」系統，只要將上面所列的其中一個元件加入至 GameObject。</span><span class="sxs-lookup"><span data-stu-id="1a67d-130">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="1a67d-131">由於所有解析器都需要 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) ，因此 Unity 會自動建立一個。</span><span class="sxs-lookup"><span data-stu-id="1a67d-131">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="1a67d-132">您可以在 **SolverExamples** 檔中找到如何使用解析器系統的範例。</span><span class="sxs-lookup"><span data-stu-id="1a67d-132">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="1a67d-133">如何變更追蹤參考</span><span class="sxs-lookup"><span data-stu-id="1a67d-133">How to change tracking reference</span></span>

<span data-ttu-id="1a67d-134">元件的 [ *追蹤的目標型別* ] 屬性 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 會定義解析器將用來計算其演算法的參考點。</span><span class="sxs-lookup"><span data-stu-id="1a67d-134">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="1a67d-135">例如，具有簡單元件的實值型別， [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 會導致來自 head 的 raycast 和使用者的注視方向，以解決遇到的介面。</span><span class="sxs-lookup"><span data-stu-id="1a67d-135">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="1a67d-136">屬性的可能值為 `TrackedTargetType` ：</span><span class="sxs-lookup"><span data-stu-id="1a67d-136">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="1a67d-137">*Head* ：參考點是主要攝影機的轉換</span><span class="sxs-lookup"><span data-stu-id="1a67d-137">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="1a67d-138">*ControllerRay*：參考點是 [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) 控制器上的轉換 (亦即</span><span class="sxs-lookup"><span data-stu-id="1a67d-138">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="1a67d-139">移動控制器或手形控制器上的指標原點) 指向線路光線的方向</span><span class="sxs-lookup"><span data-stu-id="1a67d-139">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="1a67d-140">您 `TrackedHandedness` 可以使用屬性來選取 handedness 喜好設定 (例如</span><span class="sxs-lookup"><span data-stu-id="1a67d-140">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="1a67d-141">Left、Right、Both) </span><span class="sxs-lookup"><span data-stu-id="1a67d-141">Left, Right, Both)</span></span>
* <span data-ttu-id="1a67d-142">*HandJoint*：參考點是特定手聯合的轉換</span><span class="sxs-lookup"><span data-stu-id="1a67d-142">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="1a67d-143">您 `TrackedHandedness` 可以使用屬性來選取 handedness 喜好設定 (例如</span><span class="sxs-lookup"><span data-stu-id="1a67d-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="1a67d-144">Left、Right、Both) </span><span class="sxs-lookup"><span data-stu-id="1a67d-144">Left, Right, Both)</span></span>
  * <span data-ttu-id="1a67d-145">使用  `TrackedHandJoint` 屬性來判斷要使用的聯合轉換</span><span class="sxs-lookup"><span data-stu-id="1a67d-145">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="1a67d-146">*CustomOverride*：來自所指派之的參考點 `TransformOverride`</span><span class="sxs-lookup"><span data-stu-id="1a67d-146">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="1a67d-147">針對 *ControllerRay* 和 *HandJoint* 類型，規劃求解處理常式會先嘗試提供左方控制器/手的轉換，如果前者無法使用，則為右邊，除非 `TrackedHandedness` 屬性另有指定。</span><span class="sxs-lookup"><span data-stu-id="1a67d-147">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="1a67d-148">![規劃求解範例追蹤物件](../../images/solver/TrackedObjectType-Example.gif)</span><span class="sxs-lookup"><span data-stu-id="1a67d-148">![Solver Example Tracked Object](../../images/solver/TrackedObjectType-Example.gif)</span></span>  
<span data-ttu-id="1a67d-149">*與每個 TrackedTargetType 相關聯之各種屬性的範例*</span><span class="sxs-lookup"><span data-stu-id="1a67d-149">*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1a67d-150">大部分的解析器會使用所提供之追蹤轉換目標的正向向量 `SolverHandler` 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-150">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="1a67d-151">使用 *手聯合* 追蹤的目標型別時，掌上接點的正向向量可能會指向手指，而不是透過棕櫚。</span><span class="sxs-lookup"><span data-stu-id="1a67d-151">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="1a67d-152">這取決於提供手聯合資料的平臺。</span><span class="sxs-lookup"><span data-stu-id="1a67d-152">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="1a67d-153">針對輸入模擬和 Windows Mixed Reality，它是指向多個 palm (的 *向上向量* ，亦即：</span><span class="sxs-lookup"><span data-stu-id="1a67d-153">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="1a67d-154">綠色向量為向上、藍色向量向前) 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-154">green vector is up, blue vector is forward).</span></span>
>
> ![規劃求解前移向量](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="1a67d-156">若要解決此情況，請將上的 [ *其他旋轉* ] 屬性更新 `SolverHandler` 為 **<90，0，0>**。</span><span class="sxs-lookup"><span data-stu-id="1a67d-156">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="1a67d-157">這可確保提供給解析器的正向向量會朝手向外指向掌上和離手。</span><span class="sxs-lookup"><span data-stu-id="1a67d-157">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![規劃額外的旋轉](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="1a67d-159">或者，您也可以使用 *控制器光線* 追蹤的目標型別，來取得與手形相關的類似行為。</span><span class="sxs-lookup"><span data-stu-id="1a67d-159">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="1a67d-160">如何連鎖解析器</span><span class="sxs-lookup"><span data-stu-id="1a67d-160">How to chain solvers</span></span>

<span data-ttu-id="1a67d-161">您可以將多個 `Solver` 元件新增至相同 GameObject，進而連結其演算法。</span><span class="sxs-lookup"><span data-stu-id="1a67d-161">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="1a67d-162">`SolverHandler`元件會處理相同 GameObject 上的所有解析器更新。</span><span class="sxs-lookup"><span data-stu-id="1a67d-162">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="1a67d-163">依預設， `SolverHandler` `GetComponents<Solver>()` 開始時的呼叫會以它們出現在偵測器中的順序傳回解析器。</span><span class="sxs-lookup"><span data-stu-id="1a67d-163">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="1a67d-164">此外，將 [ *已更新的連結轉換* ] 屬性設定為 [true]，會指示將 `Solver` 其計算的位置、方向 & 調整為所有解析器可存取的中繼變數 (亦即</span><span class="sxs-lookup"><span data-stu-id="1a67d-164">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="1a67d-165">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="1a67d-165">`GoalPosition`).</span></span> <span data-ttu-id="1a67d-166">若為 false，則 `Solver` 會直接更新 GameObject 的轉換。</span><span class="sxs-lookup"><span data-stu-id="1a67d-166">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="1a67d-167">藉由將轉換屬性儲存到中繼位置，其他解析器就能從中繼變數開始執行其計算。</span><span class="sxs-lookup"><span data-stu-id="1a67d-167">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="1a67d-168">這是因為 Unity 不允許更新 gameObject，而是在相同的框架內轉換成堆疊。</span><span class="sxs-lookup"><span data-stu-id="1a67d-168">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="1a67d-169">開發人員可以藉由直接設定屬性來修改解析器的執行順序 `SolverHandler.Solvers` 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-169">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="1a67d-170">如何建立新的規劃求解</span><span class="sxs-lookup"><span data-stu-id="1a67d-170">How to create a new solver</span></span>

<span data-ttu-id="1a67d-171">所有解析器都必須繼承自抽象基類 [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver) 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-171">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="1a67d-172">規劃求解擴充功能的主要需求牽涉到覆寫 `SolverUpdate` 方法。</span><span class="sxs-lookup"><span data-stu-id="1a67d-172">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="1a67d-173">在這個方法中，開發人員應該將繼承的 `GoalPosition` `GoalRotation` 和 `GoalScale` 屬性更新為所需的值。</span><span class="sxs-lookup"><span data-stu-id="1a67d-173">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="1a67d-174">此外， `SolverHandler.TransformTarget` 作為取用者所需的參考框架，通常是相當重要的。</span><span class="sxs-lookup"><span data-stu-id="1a67d-174">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="1a67d-175">下面提供的程式碼提供了一個新的規劃求解元件的範例，此元件 `InFront` 會將附加的物件2m 放在前面 `SolverHandler.TransformTarget` 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-175">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="1a67d-176">如果取用 `SolverHandler.TrackedTargetType` 者將設定為，則 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) `SolverHandler.TransformTarget` 會是相機轉換，因此這個規劃求解會將附加的 GameObject 2m 放在使用者的每個畫面格之前。</span><span class="sxs-lookup"><span data-stu-id="1a67d-176">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="1a67d-177">規劃求解的執行指南</span><span class="sxs-lookup"><span data-stu-id="1a67d-177">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="1a67d-178">常見的規劃求解屬性</span><span class="sxs-lookup"><span data-stu-id="1a67d-178">Common solver properties</span></span>

<span data-ttu-id="1a67d-179">每個求解元件都有一組完全相同的屬性，可控制核心的規劃式行為。</span><span class="sxs-lookup"><span data-stu-id="1a67d-179">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="1a67d-180">如果啟用 *平滑* 效果，則規劃求解會逐漸將 GameObject 一段時間的轉換逐漸更新為計算的值。</span><span class="sxs-lookup"><span data-stu-id="1a67d-180">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="1a67d-181">這項變更的速度取決於每個轉換元件的 *LerpTime* 屬性。</span><span class="sxs-lookup"><span data-stu-id="1a67d-181">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="1a67d-182">例如，較高的 *MoveLerpTime* 值會導致畫面格之間的移動速度變慢。</span><span class="sxs-lookup"><span data-stu-id="1a67d-182">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="1a67d-183">如果已啟用 *MaintainScale* ，則規劃求解會利用 GameObject 的預設本機規模。</span><span class="sxs-lookup"><span data-stu-id="1a67d-183">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="1a67d-184">![核心規劃求解屬性](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="1a67d-184">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="1a67d-185">*所有的規劃求解元件所繼承的通用屬性*</span><span class="sxs-lookup"><span data-stu-id="1a67d-185">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="1a67d-186">軌道</span><span class="sxs-lookup"><span data-stu-id="1a67d-186">Orbital</span></span>

<span data-ttu-id="1a67d-187">[`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital)類別是一種以標記為依據的元件，其行為類似于日光系統中的行星。</span><span class="sxs-lookup"><span data-stu-id="1a67d-187">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="1a67d-188">此規劃將可確保附加的 GameObject 會圍繞追蹤的轉換。</span><span class="sxs-lookup"><span data-stu-id="1a67d-188">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="1a67d-189">因此，如果的 *追蹤目標型* 別 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 設定為 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) ，GameObject 就會在使用者的標頭周圍套用固定位移。</span><span class="sxs-lookup"><span data-stu-id="1a67d-189">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="1a67d-190">開發人員可以修改此固定位移，讓功能表或其他場景元件在眼睛層級或 waist 層級等。</span><span class="sxs-lookup"><span data-stu-id="1a67d-190">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="1a67d-191">這是藉由修改 *區域位移* 和 *全球位移* 屬性來完成。</span><span class="sxs-lookup"><span data-stu-id="1a67d-191">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="1a67d-192">[ *方向類型* ] 屬性會決定套用至物件的旋轉（如果它應該維持其原始的旋轉），或一律面對相機或臉部（無論轉換的位置等）。</span><span class="sxs-lookup"><span data-stu-id="1a67d-192">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="1a67d-193">![Orbital 範例](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="1a67d-193">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="1a67d-194">*Orbital 範例*</span><span class="sxs-lookup"><span data-stu-id="1a67d-194">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="1a67d-195">RadialView</span><span class="sxs-lookup"><span data-stu-id="1a67d-195">RadialView</span></span>

<span data-ttu-id="1a67d-196">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView)是另一個標記式元件，它會將 GameObject 的特定部分保留在使用者的視圖的中。</span><span class="sxs-lookup"><span data-stu-id="1a67d-196">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="1a67d-197">最 *小 & 最大視圖度數* 屬性會決定 GameObject 部分的大小必須一律在視野中。</span><span class="sxs-lookup"><span data-stu-id="1a67d-197">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="1a67d-198">[ *最小 & 距離* ] 屬性可決定要從使用者保留 GameObject 的距離。</span><span class="sxs-lookup"><span data-stu-id="1a67d-198">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="1a67d-199">例如，在 GameObject 的 *最小距離* 為1m 的情況下，會將 GameObject 推離，以確保該使用者絕對不會接近1m。</span><span class="sxs-lookup"><span data-stu-id="1a67d-199">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="1a67d-200">一般而言， [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) 會搭配使用的 *追蹤目標型別* 設定為， [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) 讓元件遵循使用者的注視。</span><span class="sxs-lookup"><span data-stu-id="1a67d-200">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="1a67d-201">不過，這個元件可讓您在任何 *追蹤的目標型別* 的「 *view* 」中保持運作。</span><span class="sxs-lookup"><span data-stu-id="1a67d-201">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="1a67d-202">![RadialView 範例](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="1a67d-202">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="1a67d-203">*RadialView 範例*</span><span class="sxs-lookup"><span data-stu-id="1a67d-203">*RadialView example*</span></span>

### <a name="inbetween"></a><span data-ttu-id="1a67d-204">Receivebegindoc</span><span class="sxs-lookup"><span data-stu-id="1a67d-204">InBetween</span></span>

<span data-ttu-id="1a67d-205">[`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween)類別會在兩個轉換之間保留附加的 GameObject。</span><span class="sxs-lookup"><span data-stu-id="1a67d-205">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="1a67d-206">這兩個轉換端點是由 GameObject 本身的 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *追蹤目標型別* 和 [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 元件 *第二個追蹤的目標型別* 屬性所定義。</span><span class="sxs-lookup"><span data-stu-id="1a67d-206">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="1a67d-207">一般而言，這兩種類型都會設定為， [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) 而產生 `SolverHandler.TransformOverride` 和 `InBetween.SecondTransformOverride` 值會設定為兩個追蹤的端點。</span><span class="sxs-lookup"><span data-stu-id="1a67d-207">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="1a67d-208">在執行時間， [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 元件會 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 根據 *第二個追蹤的目標型別* 和 *第二個轉換覆寫* 屬性，建立另一個元件。</span><span class="sxs-lookup"><span data-stu-id="1a67d-208">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="1a67d-209">會 `PartwayOffset` 定義兩個轉換之間的位置，在第一次轉換時，物件應放置於0.5 的中間、1.0，以及第二個轉換的0.0。</span><span class="sxs-lookup"><span data-stu-id="1a67d-209">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="1a67d-210">![Receivebegindoc 範例](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="1a67d-210">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="1a67d-211">*使用 Receivebegindoc 規劃求解將物件保留在兩個轉換之間的範例*</span><span class="sxs-lookup"><span data-stu-id="1a67d-211">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="1a67d-212">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="1a67d-212">SurfaceMagnetism</span></span>

<span data-ttu-id="1a67d-213">其運作方式是對介面的 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 集合 LayerMask 執行 raycast，並將 GameObject 放在該點點。</span><span class="sxs-lookup"><span data-stu-id="1a67d-213">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="1a67d-214">*介面正常位移* 會將 GameObject 的距離，從表面上的垂直方向，將距離從表面上算起的距離。</span><span class="sxs-lookup"><span data-stu-id="1a67d-214">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="1a67d-215">相反地， *表面光線位移* 會將 GameObject 設定為距離表面的距離，但在 raycast 執行的方向相反。</span><span class="sxs-lookup"><span data-stu-id="1a67d-215">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="1a67d-216">因此，如果 raycast 是使用者的注視，則 GameObject 會從表面上的點擊點向相機移動較接近的線。</span><span class="sxs-lookup"><span data-stu-id="1a67d-216">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="1a67d-217">*方向模式* 會決定要套用的旋轉類型，以與表面上的法線相對應。</span><span class="sxs-lookup"><span data-stu-id="1a67d-217">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="1a67d-218">*無* -未套用旋轉</span><span class="sxs-lookup"><span data-stu-id="1a67d-218">*None* - No rotation applied</span></span>
* <span data-ttu-id="1a67d-219">*TrackedTarget* -物件會面對追蹤的轉換來推動 raycast</span><span class="sxs-lookup"><span data-stu-id="1a67d-219">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="1a67d-220">*SurfaceNormal* -物件將依據介面上的一般位置進行對齊</span><span class="sxs-lookup"><span data-stu-id="1a67d-220">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="1a67d-221">*混合* 式物件將依據介面上的法線，以及根據追蹤的轉換來對齊。</span><span class="sxs-lookup"><span data-stu-id="1a67d-221">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="1a67d-222">若要強制相關聯的 GameObject 在非 [ *無*] 的任何模式下保持垂直，請啟用 [ *保持垂直方向*]。</span><span class="sxs-lookup"><span data-stu-id="1a67d-222">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="1a67d-223">使用 [ *方向 Blend* ] 屬性可控制當 *方向模式* 設定為 [ *混合*] 時，旋轉因數之間的平衡。</span><span class="sxs-lookup"><span data-stu-id="1a67d-223">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="1a67d-224">值為0.0 時，會以 *TrackedTarget* 模式完全驅動方向，而1.0 的值將會由 *SurfaceNormal* 完全驅動方向。</span><span class="sxs-lookup"><span data-stu-id="1a67d-224">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![SurfaceMagnetism 範例](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="1a67d-226">判斷可點擊的表面</span><span class="sxs-lookup"><span data-stu-id="1a67d-226">Determining what surfaces can be hit</span></span>

<span data-ttu-id="1a67d-227">將元件新增 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 至 GameObject 時，請務必考慮 GameObject 的層級及其子系（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="1a67d-227">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="1a67d-228">元件的運作方式是執行各種類型的 raycasts，以判斷「磁鐵」本身的表面。</span><span class="sxs-lookup"><span data-stu-id="1a67d-228">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="1a67d-229">如果 [規劃求解] GameObject 在的屬性中所列的其中一個圖層上有碰撞器 `MagneticSurfaces` `SurfaceMagnetism` ，則 raycast 可能會在 GameObject 附加至它自己的碰撞點時遇到。</span><span class="sxs-lookup"><span data-stu-id="1a67d-229">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="1a67d-230">您可以藉由將主要 GameObject 和所有子系設定為 [ *忽略 Raycast* 層]，或 `MagneticSurfaces` 適當地修改 LayerMask 陣列，來避免這種奇怪的行為。</span><span class="sxs-lookup"><span data-stu-id="1a67d-230">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="1a67d-231">相反地， [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject 不會與未列在屬性中的圖層上的表面衝突 `MagneticSurfaces` 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-231">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="1a67d-232">一般來說，建議您將所有所需的表面放在專用圖層上 (例如</span><span class="sxs-lookup"><span data-stu-id="1a67d-232">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="1a67d-233">*) 介面* ，並將 `MagneticSurfaces` 屬性設定為只有這個圖層。</span><span class="sxs-lookup"><span data-stu-id="1a67d-233">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="1a67d-234">使用 [ *預設* ] 或 [ *所有專案* ] 可能會導致 UI 元件或資料指標參與規劃求解。</span><span class="sxs-lookup"><span data-stu-id="1a67d-234">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="1a67d-235">最後，raycasts 會忽略比屬性設定更遠的表面 `MaxRaycastDistance` `SurfaceMagnetism` 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-235">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="1a67d-236">具有 HandConstraint 和 HandConstraintPalmUp 的手功能表</span><span class="sxs-lookup"><span data-stu-id="1a67d-236">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![手形功能表 UX 範例](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="1a67d-238">此 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 行為提供的規劃求解會將追蹤的物件限制為可安全的 (，例如，手動 UI、功能表等) 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-238">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="1a67d-239">安全區域會被視為不會與手相交的區域。</span><span class="sxs-lookup"><span data-stu-id="1a67d-239">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="1a67d-240">[`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint)另外也包含了呼叫的衍生類別 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) ，以示範當掌上有使用者時啟動規劃求解追蹤物件的常見行為。</span><span class="sxs-lookup"><span data-stu-id="1a67d-240">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="1a67d-241">如需使用手形條件約束規劃求解來建立快顯功能表的範例，[請參閱手形功能表頁](../HandMenu.md)。</span><span class="sxs-lookup"><span data-stu-id="1a67d-241">[Please see Hand Menu page](../HandMenu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="experimental-solvers"></a><span data-ttu-id="1a67d-242">實驗性解析器</span><span class="sxs-lookup"><span data-stu-id="1a67d-242">Experimental solvers</span></span>

<span data-ttu-id="1a67d-243">這些解析器可在 MRTK 中使用，但目前為實驗性。</span><span class="sxs-lookup"><span data-stu-id="1a67d-243">These solvers are available in MRTK but are currently experimental.</span></span> <span data-ttu-id="1a67d-244">其 Api 和功能可能會變更。</span><span class="sxs-lookup"><span data-stu-id="1a67d-244">Their APIs and functionality are subject to change.</span></span> <span data-ttu-id="1a67d-245">此外，其穩定性和品質可能會比標準功能還低。</span><span class="sxs-lookup"><span data-stu-id="1a67d-245">Furthermore, their robustness and quality may be lower than standard features.</span></span>

### <a name="directional-indicator"></a><span data-ttu-id="1a67d-246">方向指標</span><span class="sxs-lookup"><span data-stu-id="1a67d-246">Directional indicator</span></span>

<span data-ttu-id="1a67d-247">[`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator)類別是沿著標記的元件，它會將自己導向至空間中所需的時間點方向。</span><span class="sxs-lookup"><span data-stu-id="1a67d-247">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="1a67d-248">當的 *追蹤目標型* 別設定為時，最常使用 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) 。</span><span class="sxs-lookup"><span data-stu-id="1a67d-248">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="1a67d-249">以這種方式，包含規劃求解的 UX 元件 [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator)  會引導使用者查看空間中所需的時間點。</span><span class="sxs-lookup"><span data-stu-id="1a67d-249">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Experimental.Utilities.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="1a67d-250">需要的空間點是透過 *方向性目標* 屬性來決定。</span><span class="sxs-lookup"><span data-stu-id="1a67d-250">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="1a67d-251">如果使用者可以看到方向性目標，或在中設定任何參考的畫面格 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) ，則此規劃求解將會停用 [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) 其下的所有元件。</span><span class="sxs-lookup"><span data-stu-id="1a67d-251">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="1a67d-252">如果無法查看，則所有專案都會在指標上啟用。</span><span class="sxs-lookup"><span data-stu-id="1a67d-252">If not viewable, then everything will be enabled on the indicator.</span></span>

* <span data-ttu-id="1a67d-253">*可見度比例因數* -乘數，以增加或減少決定 *方向性目標* 點是否可見的 FOV</span><span class="sxs-lookup"><span data-stu-id="1a67d-253">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="1a67d-254">*View Offset* -從參考框架的觀點來看 (例如</span><span class="sxs-lookup"><span data-stu-id="1a67d-254">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="1a67d-255">攝影機可能) ，此屬性會定義在指標方向中，物件是從區中央開始的距離。</span><span class="sxs-lookup"><span data-stu-id="1a67d-255">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="1a67d-256">![方向指標屬性](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="1a67d-256">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="1a67d-257">*方向指標屬性*</span><span class="sxs-lookup"><span data-stu-id="1a67d-257">*Directional Indicator properties*</span></span>

![方向指標範例場景](../../images/solver/DirectionalIndicatorExampleScene.gif)

<span data-ttu-id="1a67d-259">*方向指標範例場景 (資產/MRTK/範例/實驗/解析器/DirectionalIndicatorExample unity)*</span><span class="sxs-lookup"><span data-stu-id="1a67d-259">*Directional Indicator Example Scene (Assets/MRTK/Examples/Experimental/Solvers/DirectionalIndicatorExample.unity)*</span></span>

## <a name="see-also"></a><span data-ttu-id="1a67d-260">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1a67d-260">See also</span></span>

* [<span data-ttu-id="1a67d-261">手動追蹤</span><span class="sxs-lookup"><span data-stu-id="1a67d-261">Hand Tracking</span></span>](../../input/HandTracking.md)
* [<span data-ttu-id="1a67d-262">目光</span><span class="sxs-lookup"><span data-stu-id="1a67d-262">Gaze</span></span>](../../input/Gaze.md)
