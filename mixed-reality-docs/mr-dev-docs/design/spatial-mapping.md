---
title: 空間對應
description: 空間對應提供在 HoloLens 周圍環境中實際表面的詳細標記法。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應、HoloLens、混合現實、表面重建、網格、混合現實耳機、windows mixed reality 耳機、虛擬實境耳機、HoloLens、MRTK、混合現實工具組、場景理解、世界網格、遮蔽、物理、流覽、表面觀察器、轉譯、網格處理
ms.openlocfilehash: 3268f25f86cdfea3aa1ae0b77c4fbeb9aa0ce1b9
ms.sourcegitcommit: 8f141a843bcfc57e1b18cc606292186b8ac72641
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/19/2021
ms.locfileid: "110196423"
---
# <a name="spatial-mapping"></a><span data-ttu-id="caa99-104">空間對應</span><span class="sxs-lookup"><span data-stu-id="caa99-104">Spatial mapping</span></span>

<span data-ttu-id="caa99-105">空間對應可在 HoloLens 的環境中提供真實世界表面的詳細表示，讓開發人員能夠建立令人信服的混合現實體驗。</span><span class="sxs-lookup"><span data-stu-id="caa99-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="caa99-106">藉由將真實世界與虛擬世界合併，應用程式可以讓全像是真實的。</span><span class="sxs-lookup"><span data-stu-id="caa99-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="caa99-107">應用程式也可以藉由提供熟悉的真實世界行為和互動，更自然地配合使用者期望。</span><span class="sxs-lookup"><span data-stu-id="caa99-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a><span data-ttu-id="caa99-108">裝置支援</span><span class="sxs-lookup"><span data-stu-id="caa99-108">Device supports</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="caa99-109"><strong>功能</strong></span><span class="sxs-lookup"><span data-stu-id="caa99-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="caa99-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens (第 1 代)</strong></a></span><span class="sxs-lookup"><span data-stu-id="caa99-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="caa99-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="caa99-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="caa99-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>沉浸式頭戴裝置</strong></a></span><span class="sxs-lookup"><span data-stu-id="caa99-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="caa99-113">空間對應</span><span class="sxs-lookup"><span data-stu-id="caa99-113">Spatial mapping</span></span></td>
        <td><span data-ttu-id="caa99-114">✔️</span><span class="sxs-lookup"><span data-stu-id="caa99-114">✔️</span></span></td>
        <td><span data-ttu-id="caa99-115">✔️</span><span class="sxs-lookup"><span data-stu-id="caa99-115">✔️</span></span></td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a><span data-ttu-id="caa99-116">為什麼空間對應很重要？</span><span class="sxs-lookup"><span data-stu-id="caa99-116">Why is spatial mapping important?</span></span>

<span data-ttu-id="caa99-117">空間對應可以讓使用者將物件放置在實際的表面上。</span><span class="sxs-lookup"><span data-stu-id="caa99-117">Spatial mapping makes it possible to place objects on real surfaces.</span></span> <span data-ttu-id="caa99-118">這有助於錨定使用者世界中的物件，並充分利用真實的深度提示。根據其他的全像全像遮蔽和真實世界物件來您的全像，有助於說服使用者這些全像是在空間中。</span><span class="sxs-lookup"><span data-stu-id="caa99-118">This helps anchor objects in the user's world and takes advantage of real world depth cues. Occluding your holograms based on other holograms and real world objects helps convince the user that these holograms are actually in their space.</span></span> <span data-ttu-id="caa99-119">以空間浮動的全像移動空間或與使用者移動並不會覺得真實的。</span><span class="sxs-lookup"><span data-stu-id="caa99-119">Holograms floating in space or moving with the user won't feel as real.</span></span> <span data-ttu-id="caa99-120">可能的話，請將專案放在更舒適的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-120">When possible, place items for comfort.</span></span>

<span data-ttu-id="caa99-121">在放置或移動全像移動 (使用投影出的方格) 時，將表面視覺化。</span><span class="sxs-lookup"><span data-stu-id="caa99-121">Visualize surfaces when placing or moving holograms (use a projected grid).</span></span> <span data-ttu-id="caa99-122">這可協助使用者知道其最適合放置全息的位置，並顯示他們嘗試放置全像全像的地方是否未對應。</span><span class="sxs-lookup"><span data-stu-id="caa99-122">This helps users know where they can best place their holograms, and shows if the spot they're trying to place the hologram isn't mapped.</span></span> <span data-ttu-id="caa99-123">如果使用者的角度太多，您可以向使用者「佈告欄專案」。</span><span class="sxs-lookup"><span data-stu-id="caa99-123">You can "billboard items" toward the user if they end up at too much of an angle.</span></span>

## <a name="conceptual-overview"></a><span data-ttu-id="caa99-124">概念概觀</span><span class="sxs-lookup"><span data-stu-id="caa99-124">Conceptual overview</span></span>

<span data-ttu-id="caa99-125">![涵蓋房間的網格表面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="caa99-125">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="caa99-126">*涵蓋房間的空間地圖網格範例*</span><span class="sxs-lookup"><span data-stu-id="caa99-126">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="caa99-127">空間對應所使用的兩種主要物件類型為「空間介面觀察者」和「空間介面」。</span><span class="sxs-lookup"><span data-stu-id="caa99-127">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="caa99-128">應用程式會提供具有一或多個周框磁片區的空間介面觀察器，以定義應用程式希望接收空間對應資料的空間區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-128">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="caa99-129">針對上述每個磁片區，空間對應將會為應用程式提供一組空間表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-129">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="caa99-130">這些磁片區可能是固定位置中的固定 (（以真實世界) 為基礎），或者它們可能會附加到 HoloLens (，但不會在透過環境) 移至 HoloLens 的情況下輪替。</span><span class="sxs-lookup"><span data-stu-id="caa99-130">These volumes may be stationary (in a fixed location based on the real world) or they may be attached to the HoloLens (they move, but don't rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="caa99-131">每個空間介面都會以少量的空間描述真實世界表面，以連接到世界鎖定 [空間座標系統](coordinate-systems.md)的三角形網格表示。</span><span class="sxs-lookup"><span data-stu-id="caa99-131">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="caa99-132">當 HoloLens 收集有關環境的新資料，且發生環境變更時，空間介面會出現、消失及變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-132">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear, and change.</span></span>

## <a name="spatial-awareness-design-concepts-demo"></a><span data-ttu-id="caa99-133">空間感知設計概念示範</span><span class="sxs-lookup"><span data-stu-id="caa99-133">Spatial Awareness design concepts demo</span></span>

<span data-ttu-id="caa99-134">如果您想要看到空間感知設計概念的實際運作，請參閱下面 **的設計全像影像空間感知** 影片示範。</span><span class="sxs-lookup"><span data-stu-id="caa99-134">If you'd like to see Spatial Awareness design concepts in action, check out our **Designing Holograms - Spatial Awareness** video demo below.</span></span> <span data-ttu-id="caa99-135">當您完成時，請繼續進行，以深入瞭解特定主題。</span><span class="sxs-lookup"><span data-stu-id="caa99-135">When you've finished, continue on for a more detailed dive into specific topics.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Microsofts-Designing-Holograms-Spatial-Awareness-Chapter/player]

<span data-ttu-id="caa99-136">*這段影片取自「設計全像」應用程式 HoloLens 2 應用程式。下載並享有完整 [的體驗。](https://aka.ms/dhapp)*</span><span class="sxs-lookup"><span data-stu-id="caa99-136">*This video was taken from the "Designing Holograms" HoloLens 2 app. Download and enjoy the full experience [here](https://aka.ms/dhapp).*</span></span>

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a><span data-ttu-id="caa99-137">空間對應與場景的比較理解 WorldMesh</span><span class="sxs-lookup"><span data-stu-id="caa99-137">Spatial Mapping vs. Scene Understanding WorldMesh</span></span>

<span data-ttu-id="caa99-138">針對 HoloLens 2，可以使用 [場景理解 SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 設定) 查詢靜態版本的空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="caa99-138">For HoloLens 2, it's possible to query a static version of the spatial mapping data using [Scene understanding SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh setting).</span></span> <span data-ttu-id="caa99-139">以下是存取空間對應資料的兩種方式之間的差異：</span><span class="sxs-lookup"><span data-stu-id="caa99-139">Here are the differences between two ways of accessing the spatial mapping data:</span></span>
* <span data-ttu-id="caa99-140">空間對應 API：</span><span class="sxs-lookup"><span data-stu-id="caa99-140">Spatial Mapping API:</span></span>
   * <span data-ttu-id="caa99-141">有限範圍：適用于應用程式的空間對應資料，以有限大小的快取「反升」方式提供給使用者。</span><span class="sxs-lookup"><span data-stu-id="caa99-141">Limited range: the spatial mapping data available to applications in a limited size cached 'bubble' around the user.</span></span>
   * <span data-ttu-id="caa99-142">透過 SurfacesChanged 事件提供變更網格區域的低延遲更新。</span><span class="sxs-lookup"><span data-stu-id="caa99-142">Provides low latency updates of changed mesh regions through SurfacesChanged events.</span></span>
   * <span data-ttu-id="caa99-143">依每個三立方計量參數的三角形所控制的詳細詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="caa99-143">Variable level of details controlled by Triangles Per Cubic Meter parameter.</span></span>
* <span data-ttu-id="caa99-144">場景理解 SDK：</span><span class="sxs-lookup"><span data-stu-id="caa99-144">Scene understanding SDK:</span></span>
   * <span data-ttu-id="caa99-145">無限制範圍-提供查詢半徑內所有掃描的空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="caa99-145">Unlimited range - provides all the scanned spatial mapping data within the query radius.</span></span>
   * <span data-ttu-id="caa99-146">提供空間對應資料的靜態快照集。</span><span class="sxs-lookup"><span data-stu-id="caa99-146">Provides a static snapshot of the spatial mapping data.</span></span> <span data-ttu-id="caa99-147">取得更新的空間對應資料需要對整個網格執行新的查詢。</span><span class="sxs-lookup"><span data-stu-id="caa99-147">Getting the updated spatial mapping data requires running a new query for the whole mesh.</span></span>
   * <span data-ttu-id="caa99-148">RequestedMeshLevelOfDetail 設定所控制的一致詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="caa99-148">Consistent level of details controlled by RequestedMeshLevelOfDetail setting.</span></span>

## <a name="what-influences-spatial-mapping-quality"></a><span data-ttu-id="caa99-149">什麼會影響空間對應品質？</span><span class="sxs-lookup"><span data-stu-id="caa99-149">What influences spatial mapping quality?</span></span>

<span data-ttu-id="caa99-150">[這裡](/hololens/hololens-environment-considerations)詳述的數個因素可能會影響這些錯誤的頻率和嚴重性。</span><span class="sxs-lookup"><span data-stu-id="caa99-150">Several factors, detailed [here](/hololens/hololens-environment-considerations), can affect the frequency and severity of these errors.</span></span>  <span data-ttu-id="caa99-151">不過，您應該設計您的應用程式，讓使用者即使在空間對應資料中發生錯誤，也可以達成其目標。</span><span class="sxs-lookup"><span data-stu-id="caa99-151">However, you should design your application so that the user can achieve their goals even in the presence of errors in the spatial mapping data.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="caa99-152">常見使用案例</span><span class="sxs-lookup"><span data-stu-id="caa99-152">Common usage scenarios</span></span>

![一般空間對應使用案例的圖例：位置、遮蔽、物理和導覽](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="caa99-154">放置</span><span class="sxs-lookup"><span data-stu-id="caa99-154">Placement</span></span>

<span data-ttu-id="caa99-155">空間對應讓應用程式有機會為使用者呈現自然且熟悉的互動形式;將您的電話放在桌上是什麼自然？</span><span class="sxs-lookup"><span data-stu-id="caa99-155">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing down your phone on the desk?</span></span>

<span data-ttu-id="caa99-156">限制 (或更多的地理空間位置的位置。) 到表面上的任何空間位置選擇，都會提供從 3D () 點到 surface (上 2D) 點的自然對應。</span><span class="sxs-lookup"><span data-stu-id="caa99-156">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="caa99-157">這可減少使用者提供給應用程式所需的資訊量，讓使用者的互動速度更快、更容易且更精確。</span><span class="sxs-lookup"><span data-stu-id="caa99-157">This reduces the amount of information the user needs to provide to the application and makes the user's interactions faster, easier, and more precise.</span></span> <span data-ttu-id="caa99-158">這是因為「離離」不是我們用來與其他人或電腦實際通訊的內容。</span><span class="sxs-lookup"><span data-stu-id="caa99-158">This is true because 'distance away' isn't something that we're used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="caa99-159">當我們指向手指時，會指定方向，但不是距離。</span><span class="sxs-lookup"><span data-stu-id="caa99-159">When we point with our finger, we're specifying a direction but not a distance.</span></span>

<span data-ttu-id="caa99-160">其中一個重要的警告是，當應用程式從方向推斷距離 (例如，沿著使用者的注視方向 raycast，以找出最接近的空間介面) 時，這必須產生使用者可以可靠地預測的結果。</span><span class="sxs-lookup"><span data-stu-id="caa99-160">An important caveat here's that when an application infers distance from direction (for example by doing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user can reliably predict.</span></span> <span data-ttu-id="caa99-161">否則，使用者將會失去其控制的意義，而這可能很快就會很令人沮喪。</span><span class="sxs-lookup"><span data-stu-id="caa99-161">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="caa99-162">其中一個有助於進行這項作業的方法，就是進行多個 raycasts，而不是只有一個。</span><span class="sxs-lookup"><span data-stu-id="caa99-162">One method that helps with this is to do multiple raycasts instead of just one.</span></span> <span data-ttu-id="caa99-163">匯總結果應更平滑且更容易預測，較不容易影響暫時性的「極端」結果 (原因可能是因為光線通過小洞，或是達到使用者不知道) 的少量幾何。</span><span class="sxs-lookup"><span data-stu-id="caa99-163">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user isn't aware of).</span></span> <span data-ttu-id="caa99-164">您也可以在一段時間內執行匯總或平滑處理;例如，您可以限制每個全息圖的最大速度，與使用者的距離不同。</span><span class="sxs-lookup"><span data-stu-id="caa99-164">Aggregation or smoothing can also be performed over time; for example, you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="caa99-165">只要限制最小值和最大距離值也會有所説明，因此移動的全像影像也不會突然離開到距離，或損毀到使用者的臉部。</span><span class="sxs-lookup"><span data-stu-id="caa99-165">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved doesn't suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="caa99-166">應用程式也可以使用表面的圖形和方向來引導全息圖放置。</span><span class="sxs-lookup"><span data-stu-id="caa99-166">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="caa99-167">全像椅子的椅子不應該穿透牆，而且即使是稍微不平均，也應該排清地面。</span><span class="sxs-lookup"><span data-stu-id="caa99-167">A holographic chair shouldn't penetrate through walls and should sit flush with the floor even if it's slightly uneven.</span></span> <span data-ttu-id="caa99-168">這類功能可能依賴物理衝突，而不是 raycasts，不過也適用類似的考慮。</span><span class="sxs-lookup"><span data-stu-id="caa99-168">This kind of functionality would likely rely upon the use of physics collisions rather than raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="caa99-169">如果要放置的全息圖案有許多小型多邊形，例如椅子上的腿，將這些多邊形的物理表示擴展至更寬且更平滑的位置，讓它們更能在沒有畫面的情況下滑出空間表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-169">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they're more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="caa99-170">在極端的情況下，使用者輸入可以完全簡化，而空間介面可用來完全自動進行全像投影放置。</span><span class="sxs-lookup"><span data-stu-id="caa99-170">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to do entirely automatic hologram placement.</span></span> <span data-ttu-id="caa99-171">例如，應用程式可以在牆上的某處放置全像 light 切換，讓使用者按下。</span><span class="sxs-lookup"><span data-stu-id="caa99-171">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="caa99-172">有關可預測性的相同注意事項也適用于此處。如果使用者想要控制全息圖放置，但應用程式不一定會將影像放在其預期的位置 (如果燈光出現在使用者無法觸達) 的某個位置，則這會是令人沮喪的體驗。</span><span class="sxs-lookup"><span data-stu-id="caa99-172">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application doesn't always place holograms where they expect (if the light-switch appears somewhere that the user can't reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="caa99-173">它實際上可能更糟的是，自動放置需要使用者更正的時間，而不是只需要使用者永遠自行放置;由於預期自動放置 *應該* 會成功，因此手動更正會像是負擔一樣！</span><span class="sxs-lookup"><span data-stu-id="caa99-173">It can actually be worse to do automatic placement that requires user correction some of the time, than to just require the user to always do placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="caa99-174">另請注意，應用程式使用空間介面進行放置的能力，主要取決於應用程式的 [掃描體驗](spatial-mapping.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="caa99-174">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="caa99-175">如果介面尚未掃描，則無法用於放置。</span><span class="sxs-lookup"><span data-stu-id="caa99-175">If a surface hasn't been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="caa99-176">應用程式是由應用程式對使用者進行清楚的設定，讓他們可以協助掃描新的表面或選取新的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-176">It's up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="caa99-177">在放置期間，對使用者的視覺效果意見反應最為重要。</span><span class="sxs-lookup"><span data-stu-id="caa99-177">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="caa99-178">使用者必須知道全像是以 [接地效果](spatial-mapping.md#visualization)最接近的表面為基礎的全像影像。</span><span class="sxs-lookup"><span data-stu-id="caa99-178">The user needs to know where the hologram is based on the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="caa99-179">他們應該瞭解如何將其全息影像的移動限制 (例如，因為與另一個附近的表面) 發生衝突。</span><span class="sxs-lookup"><span data-stu-id="caa99-179">They should understand why the movement of their hologram is being constrained (for example, because of collisions with another nearby surface).</span></span> <span data-ttu-id="caa99-180">如果它們無法將全像放在目前的位置，則視覺效果的意見反應應該讓它清楚說明為何。</span><span class="sxs-lookup"><span data-stu-id="caa99-180">If they can't place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="caa99-181">比方說，如果使用者想要將全像沙發的一半帶到牆中，則牆後方的沙發部分應該以生氣的色彩 pulsate。</span><span class="sxs-lookup"><span data-stu-id="caa99-181">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="caa99-182">相反地，如果應用程式在使用者可以看到真實世界表面的位置找不到空間介面，則應用程式應該將它清除。</span><span class="sxs-lookup"><span data-stu-id="caa99-182">Or conversely, if the application can't find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="caa99-183">在此區域中沒有明顯的接地效果，可能會達到這個目的。</span><span class="sxs-lookup"><span data-stu-id="caa99-183">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="caa99-184">遮蔽</span><span class="sxs-lookup"><span data-stu-id="caa99-184">Occlusion</span></span>

<span data-ttu-id="caa99-185">空間對應介面的主要用途之一，就是遮蔽全像影像。</span><span class="sxs-lookup"><span data-stu-id="caa99-185">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="caa99-186">這種簡單的行為會大幅影響全像全像的全像的全像投影，可協助建立 visceral 的意義，以真正理解與使用者相同的實體空間。</span><span class="sxs-lookup"><span data-stu-id="caa99-186">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabits the same physical space as the user.</span></span>

<span data-ttu-id="caa99-187">遮蔽也會提供資訊給使用者;當真實世界表面 pixels occluded 的全像影像時，這會提供額外的視覺效果意見反應，以提供給世界上該全像影像的空間位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-187">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides extra visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="caa99-188">相反地，遮蔽也可以常見 *隱藏* 使用者的資訊;遮蔽牆後方的全像投影可以直覺地減少視覺效果。</span><span class="sxs-lookup"><span data-stu-id="caa99-188">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="caa99-189">若要隱藏或顯示全像影像，使用者只需要移動自己的標頭。</span><span class="sxs-lookup"><span data-stu-id="caa99-189">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="caa99-190">遮蔽也可以用來根據熟悉的實體互動，對自然使用者介面的期望進行質數;如果影像是由表面 pixels occluded，就是因為表面是實心的，所以使用者應該預期全像影像會與該表面發生 *衝突* ，而不會通過它。</span><span class="sxs-lookup"><span data-stu-id="caa99-190">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not pass through it.</span></span>

<span data-ttu-id="caa99-191">有時，不需要遮蔽全像影像。</span><span class="sxs-lookup"><span data-stu-id="caa99-191">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="caa99-192">如果使用者需要與全息圖互動，則他們需要查看它，即使是在真實世界表面上也一樣。</span><span class="sxs-lookup"><span data-stu-id="caa99-192">If a user needs to interact with a hologram, then they need to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="caa99-193">在這種情況下，在 pixels occluded (時，以不同的方式呈現這類全息圖，例如降低其亮度) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-193">In such cases, it usually makes sense to render such a hologram differently when it's occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="caa99-194">如此一來，使用者就能以視覺化的方式找出全像影像，但仍然知道它背後的東西。</span><span class="sxs-lookup"><span data-stu-id="caa99-194">This way, the user can visually locate the hologram, but they'll still know it's behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="caa99-195">物理特性</span><span class="sxs-lookup"><span data-stu-id="caa99-195">Physics</span></span>

<span data-ttu-id="caa99-196">使用物理模擬是另一種方式，可用來在使用者的實體空間中強調 *顯示* 全像影像。</span><span class="sxs-lookup"><span data-stu-id="caa99-196">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="caa99-197">當我的全像橡膠球從桌上走出來時，在樓層間彈跳，並在沙發下消失時，我可能很難相信它不存在。</span><span class="sxs-lookup"><span data-stu-id="caa99-197">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not there.</span></span>

<span data-ttu-id="caa99-198">物理模擬也讓應用程式有機會使用自然且熟悉的物理互動。</span><span class="sxs-lookup"><span data-stu-id="caa99-198">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="caa99-199">如果傢俱以適當的慣性和摩擦在地面之間滑動，則在地面上移動一小段的全像傢俱可能更容易。</span><span class="sxs-lookup"><span data-stu-id="caa99-199">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="caa99-200">若要產生實際的實體行為，您可能需要進行一些 [網格處理](spatial-mapping.md#mesh-processing) ，例如填滿孔洞、移除浮動 hallucinations 和平滑表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-200">To generate realistic physical behaviors, you'll likely need to do some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="caa99-201">您也必須考慮應用程式的 [掃描體驗](spatial-mapping.md#the-environment-scanning-experience) 會如何影響其物理模擬。</span><span class="sxs-lookup"><span data-stu-id="caa99-201">You'll also need to consider how your application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="caa99-202">首先，遺漏的表面將不會與任何值衝突;當橡膠球在 corridor 和已知世界結束時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="caa99-202">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="caa99-203">其次，您必須決定是否要在一段時間後繼續回應環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-203">Secondly, you need to decide whether you'll continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="caa99-204">在某些情況下，您會想要儘快回應;比方說，如果使用者使用門和傢俱作為內送羅馬箭號 tempest 的可移動 barricades。</span><span class="sxs-lookup"><span data-stu-id="caa99-204">In some cases, you'll want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="caa99-205">但在其他情況下，您可能會想要忽略新的更新;如果您的狗決定坐在播放軌的中間，讓您的全像 racetrack 在地面上推動您的全像運動車，可能突然不太有趣。</span><span class="sxs-lookup"><span data-stu-id="caa99-205">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="caa99-206">導覽</span><span class="sxs-lookup"><span data-stu-id="caa99-206">Navigation</span></span>

<span data-ttu-id="caa99-207">應用程式可以使用空間對應資料來授與全息字元 (或代理程式) 能夠以真實人員的相同方式流覽真實世界。</span><span class="sxs-lookup"><span data-stu-id="caa99-207">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="caa99-208">這有助於加強全像攝影字元的存在，方法是將其限制為與使用者和朋友的相同自然、熟悉的行為集合。</span><span class="sxs-lookup"><span data-stu-id="caa99-208">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="caa99-209">流覽功能也可能對使用者很有説明。</span><span class="sxs-lookup"><span data-stu-id="caa99-209">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="caa99-210">一旦在指定的區域內建了導覽對應，就可以共用它，為不熟悉該位置的新使用者提供全像方向的指示。</span><span class="sxs-lookup"><span data-stu-id="caa99-210">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="caa99-211">此對應的設計目的是為了協助讓地下的流量順暢地流動，或避免發生在結構網站等危險位置的意外情況。</span><span class="sxs-lookup"><span data-stu-id="caa99-211">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="caa99-212">執行導覽功能時所牽涉到的關鍵技術挑戰，將會對 walkable 表面進行可靠的偵測， (人類不會逐步解說資料表！ ) 和適當地調整環境中的變更 (人類不會逐步解說 ) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-212">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="caa99-213">網格可能需要進行一些 [處理](spatial-mapping.md#mesh-processing) ，才能用於路徑規劃和依虛擬字元進行導覽。</span><span class="sxs-lookup"><span data-stu-id="caa99-213">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it's usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="caa99-214">將網格平滑化並移除 hallucinations，可能有助於避免字元變成停滯。</span><span class="sxs-lookup"><span data-stu-id="caa99-214">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="caa99-215">您也可能想要大幅簡化網格，以加速您的字元路徑規劃和導覽計算。</span><span class="sxs-lookup"><span data-stu-id="caa99-215">You may also wish to drastically simplify the mesh to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="caa99-216">這些挑戰在開發影片遊戲技術方面已有很大的説明，而且有許多關於這些主題的可用研究文獻。</span><span class="sxs-lookup"><span data-stu-id="caa99-216">These challenges have received a great deal of attention in the development of video game technology, and there's a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="caa99-217">Unity 中的內建 NavMesh 功能無法搭配空間對應介面使用。</span><span class="sxs-lookup"><span data-stu-id="caa99-217">The built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="caa99-218">這是因為在應用程式啟動之前不知道空間對應介面，但必須事先從來源資產產生 NavMesh 資料檔案。</span><span class="sxs-lookup"><span data-stu-id="caa99-218">This is because spatial mapping surfaces aren't known until the application starts, but NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="caa99-219">另請注意，空間對應系統將不會提供離使用者目前位置更 [遠的表面資訊](spatial-mapping.md#the-environment-scanning-experience) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-219">Also note that, the spatial mapping system won't provide [information about surfaces far away](spatial-mapping.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="caa99-220">因此，如果應用程式要建立大型區域的地圖，就必須「記住」。</span><span class="sxs-lookup"><span data-stu-id="caa99-220">So the application must 'remember' surfaces itself if it's to build a map of a large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="caa99-221">視覺效果</span><span class="sxs-lookup"><span data-stu-id="caa99-221">Visualization</span></span>

<span data-ttu-id="caa99-222">大部分的時間都適合讓空間表面變成不可見;為了將視覺效果雜亂降至最低，並讓真實世界說出本身。</span><span class="sxs-lookup"><span data-stu-id="caa99-222">Most of the time it's appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="caa99-223">不過，有時候直接視覺化空間對應介面會很有用，儘管它們的真實世界對應專案都是可見的。</span><span class="sxs-lookup"><span data-stu-id="caa99-223">However, sometimes it's useful to visualize spatial mapping surfaces directly, despite their real-world counterparts being visible.</span></span>

<span data-ttu-id="caa99-224">例如，當使用者嘗試將全像放在表面上時， (將全像是放在牆上的全像) ，就可以藉由將陰影轉換成表面，來「地面」「地面」。</span><span class="sxs-lookup"><span data-stu-id="caa99-224">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="caa99-225">這樣可讓使用者更清楚地瞭解全像全像全像是全像是全像全像是全像是全像是</span><span class="sxs-lookup"><span data-stu-id="caa99-225">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="caa99-226">這也是在使用者認可變更之前，以視覺化方式「預覽」變更的一般作法範例。</span><span class="sxs-lookup"><span data-stu-id="caa99-226">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="caa99-227">藉由視覺化介面，應用程式可以與使用者共用環境的理解。</span><span class="sxs-lookup"><span data-stu-id="caa99-227">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="caa99-228">例如，全像攝影板的遊戲可將其識別為「資料表」的水準表面視覺化，讓使用者知道他們應該前往哪裡進行互動。</span><span class="sxs-lookup"><span data-stu-id="caa99-228">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="caa99-229">視覺化介面可以用來顯示隱藏于視野中的使用者附近空間。</span><span class="sxs-lookup"><span data-stu-id="caa99-229">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="caa99-230">這可能會讓使用者能夠存取其廚房 (，以及其所包含的全像全像的全像房間) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-230">This could provide a way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="caa99-231">空間對應所提供的介面網格可能不是特別的「清除」。</span><span class="sxs-lookup"><span data-stu-id="caa99-231">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="caa99-232">請務必適當地將它們視覺化。</span><span class="sxs-lookup"><span data-stu-id="caa99-232">It's important to visualize them appropriately.</span></span> <span data-ttu-id="caa99-233">傳統的光源計算可能會以視覺化方式反白顯示 surface 法線中的錯誤，而「清理」紋理則投射在表面上可能有助於提供整齊的外觀。</span><span class="sxs-lookup"><span data-stu-id="caa99-233">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, while 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="caa99-234">您也可以在呈現介面之前，進行 [網格處理](spatial-mapping.md#mesh-processing) 以改善網格屬性。</span><span class="sxs-lookup"><span data-stu-id="caa99-234">It's also possible to do [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

> [!NOTE]
> <span data-ttu-id="caa99-235">HoloLens 2 會採用新的 [場景理解運行](scene-understanding.md)時間，為混合的現實開發人員提供結構化、高階的環境標記法，其設計目的是要簡化放置、遮蔽、物理和流覽的執行。</span><span class="sxs-lookup"><span data-stu-id="caa99-235">HoloLens 2 implements a new [Scene Understanding Runtime](scene-understanding.md), that provides Mixed Reality developers with a structured, high-level environment representation designed to simplify the implementation of placement, occlusion, physics and navigation.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="caa99-236">使用介面觀察者</span><span class="sxs-lookup"><span data-stu-id="caa99-236">Using The Surface Observer</span></span>

<span data-ttu-id="caa99-237">空間對應的起點是介面觀察者。</span><span class="sxs-lookup"><span data-stu-id="caa99-237">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="caa99-238">程式流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="caa99-238">Program flow is as follows:</span></span>
* <span data-ttu-id="caa99-239">建立 surface observer 物件</span><span class="sxs-lookup"><span data-stu-id="caa99-239">Create a surface observer object</span></span>
   * <span data-ttu-id="caa99-240">提供一個或多個空間磁片區，以定義應用程式希望接收空間對應資料的相關區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-240">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="caa99-241">空間磁片區只是定義空間區域（例如球體或方塊）的圖形。</span><span class="sxs-lookup"><span data-stu-id="caa99-241">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="caa99-242">使用具有世界鎖定空間座標系統的空間磁片區，以識別實體世界的固定區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-242">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="caa99-243">使用空間磁片區，以主體鎖定的空間座標系統更新每個畫面格，以識別移動 (但不會向使用者旋轉) 的空間區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-243">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but doesn't rotate) with the user.</span></span>
   * <span data-ttu-id="caa99-244">這些空間磁片區稍後可能會變更，因為應用程式或使用者的狀態會變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-244">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="caa99-245">使用輪詢或通知取得空間介面的相關資訊</span><span class="sxs-lookup"><span data-stu-id="caa99-245">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="caa99-246">您可以隨時「輪詢」空間介面狀態的表面觀察器。</span><span class="sxs-lookup"><span data-stu-id="caa99-246">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="caa99-247">相反地，您可能會註冊介面觀察者的「介面變更」事件，這會在空間表面變更時通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="caa99-247">Instead, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="caa99-248">如果是動態空間磁片區（例如，視圖的分隔或主體鎖定的磁片區），則應用程式必須藉由設定感興趣的區域，然後取得目前的空間介面集，來輪詢每個畫面格的變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-248">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="caa99-249">針對靜態磁片區（例如涵蓋單一房間的全球鎖定 cube），應用程式可能會註冊「表面變更」事件，以在該磁片區內的空間表面變更時收到通知。</span><span class="sxs-lookup"><span data-stu-id="caa99-249">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="caa99-250">進程介面變更</span><span class="sxs-lookup"><span data-stu-id="caa99-250">Process surfaces changes</span></span>
   * <span data-ttu-id="caa99-251">反覆運算提供的空間介面集。</span><span class="sxs-lookup"><span data-stu-id="caa99-251">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="caa99-252">將空間表面分類為已新增、變更或移除。</span><span class="sxs-lookup"><span data-stu-id="caa99-252">Classify spatial surfaces as added, changed, or removed.</span></span>
   * <span data-ttu-id="caa99-253">針對每個新增或變更的空間介面，如果適當地提交非同步要求，以在所需的詳細資料層級上接收代表 surface 目前狀態的更新網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-253">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="caa99-254">處理非同步網狀要求 () 的下列各節中有更多詳細資料。</span><span class="sxs-lookup"><span data-stu-id="caa99-254">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="caa99-255">網格快取</span><span class="sxs-lookup"><span data-stu-id="caa99-255">Mesh Caching</span></span>

<span data-ttu-id="caa99-256">空間介面會以密集三角形網格來表示。</span><span class="sxs-lookup"><span data-stu-id="caa99-256">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="caa99-257">儲存、轉譯和處理這些網格可以耗用大量的計算和儲存體資源。</span><span class="sxs-lookup"><span data-stu-id="caa99-257">Storing, rendering, and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="caa99-258">因此，每個應用程式都應該採用適合其需求的網格快取配置，以將用於網格處理和儲存的資源降至最低。</span><span class="sxs-lookup"><span data-stu-id="caa99-258">As such, each application should adopt a mesh caching scheme appropriate to its needs, to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="caa99-259">此配置應決定要保留哪些網格和要捨棄哪些，以及何時更新每個空間介面的網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-259">This scheme should determine which meshes to keep and which to discard, and when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="caa99-260">這裡討論的許多考慮都會直接通知應用程式應該如何處理網格快取。</span><span class="sxs-lookup"><span data-stu-id="caa99-260">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="caa99-261">您應該考慮使用者在環境中的移動方式、何時會觀察到不同的介面，以及何時應捕捉環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-261">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="caa99-262">當解釋介面觀察器所提供的「介面變更」事件時，基本網格快取邏輯如下所示：</span><span class="sxs-lookup"><span data-stu-id="caa99-262">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="caa99-263">如果應用程式看到先前未看到的空間介面識別碼，則應該將它視為新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="caa99-263">If the application sees a spatial surface ID that it hasn't seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="caa99-264">如果應用程式看到具有已知識別碼但有新更新時間的空間介面，則應該將其視為更新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="caa99-264">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="caa99-265">如果應用程式不再看到具有已知識別碼的空間介面，則應該將其視為已移除的空間介面。</span><span class="sxs-lookup"><span data-stu-id="caa99-265">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="caa99-266">接著，每個應用程式都必須進行下列選擇：</span><span class="sxs-lookup"><span data-stu-id="caa99-266">It's up to each application to then make the following choices:</span></span>
* <span data-ttu-id="caa99-267">針對新的空間介面，是否應要求網格？</span><span class="sxs-lookup"><span data-stu-id="caa99-267">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="caa99-268">通常應該針對新的空間介面立即要求網格，這可能會為使用者提供實用的新資訊。</span><span class="sxs-lookup"><span data-stu-id="caa99-268">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="caa99-269">不過，在使用者附近和前方的新空間介面應該具有優先權，且應先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-269">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="caa99-270">如果不需要新的網狀，例如應用程式已永久或暫時「凍結」其環境模型，則不應要求。</span><span class="sxs-lookup"><span data-stu-id="caa99-270">If the new mesh isn't needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it shouldn't be requested.</span></span>
* <span data-ttu-id="caa99-271">針對更新的空間介面，是否應要求網格？</span><span class="sxs-lookup"><span data-stu-id="caa99-271">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="caa99-272">已更新使用者附近和前方的空間表面應獲得優先考慮，而且應該先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-272">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="caa99-273">您也可以在新表面上給予較高的優先順序，而不是更新的表面，尤其是在掃描體驗期間。</span><span class="sxs-lookup"><span data-stu-id="caa99-273">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="caa99-274">若要限制處理成本，應用程式可能會想要對其處理空間表面更新的速率進行節流處理。</span><span class="sxs-lookup"><span data-stu-id="caa99-274">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="caa99-275">可能會推斷空間介面的變更是次要的，例如，如果表面的界限很小，在此情況下，更新可能不太重要而無法處理。</span><span class="sxs-lookup"><span data-stu-id="caa99-275">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="caa99-276">在使用者感興趣的目前區域以外的空間介面更新可能完全被忽略，不過在此情況下，修改介面觀察器所使用的空間界限磁片區可能更有效率。</span><span class="sxs-lookup"><span data-stu-id="caa99-276">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="caa99-277">針對已移除的空間介面，是否應捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="caa99-277">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="caa99-278">通常應該針對移除的空間表面立即捨棄網格，讓全像遮蔽維持正確。</span><span class="sxs-lookup"><span data-stu-id="caa99-278">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="caa99-279">但是，如果應用程式有理由認為空間介面會根據使用者體驗) 的設計而 (重新出現，則比起捨棄其網格並重新建立它可能更有效率。</span><span class="sxs-lookup"><span data-stu-id="caa99-279">However, if the application has reason to believe that a spatial surface will reappear shortly (based upon the design of the user experience), then it may be more efficient to keep it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="caa99-280">如果應用程式正在建立使用者環境的大規模模型，則可能完全不想要捨棄任何網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-280">If the application is building a large-scale model of the user's environment, then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="caa99-281">不過，它仍然需要限制資源使用量，可能是因為空間表面消失而將網格幕後處理至磁片。</span><span class="sxs-lookup"><span data-stu-id="caa99-281">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="caa99-282">在空間介面產生期間，有些相當罕見的事件可能會導致空間介面由類似位置中的新空間介面取代，但使用不同的識別碼。</span><span class="sxs-lookup"><span data-stu-id="caa99-282">Some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="caa99-283">因此，選擇不捨棄已移除表面的應用程式，應該要注意的是，不會有多個高度重迭的空間介面網格涵蓋相同的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-283">So, applications that choose not to discard a removed surface should take care not to end up with multiple highly overlapped spatial surfaces meshes covering the same location.</span></span>
* <span data-ttu-id="caa99-284">是否應該針對任何其他空間表面捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="caa99-284">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="caa99-285">即使空間介面存在，如果該介面不再適用于使用者的體驗，則應該將它捨棄。</span><span class="sxs-lookup"><span data-stu-id="caa99-285">Even while a spatial surface exists, if it's no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="caa99-286">例如，如果應用程式「以替代的虛擬空間取代」門口另一端的房間，則該房間內的空間表面將不再重要。</span><span class="sxs-lookup"><span data-stu-id="caa99-286">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="caa99-287">以下是使用空間和時態性滯後的範例網格快取策略：</span><span class="sxs-lookup"><span data-stu-id="caa99-287">Here's an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="caa99-288">假設有一個應用程式想要使用在使用者看起來類似的錐形空間磁片區，然後在使用者看起來和四處四處討論。</span><span class="sxs-lookup"><span data-stu-id="caa99-288">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="caa99-289">空間介面可能會暫時從此磁片區消失，因為使用者從表面看起來不到它的表面或步驟 .。。請稍後再回頭查看或移動更近的時間。</span><span class="sxs-lookup"><span data-stu-id="caa99-289">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="caa99-290">在此情況下，捨棄並重新建立此介面的網格表示許多重複的 processings。</span><span class="sxs-lookup"><span data-stu-id="caa99-290">In this case, discarding and re-creating the mesh for this surface represents many redundant processings.</span></span>
* <span data-ttu-id="caa99-291">為了減少已處理的變更數目，應用程式會使用兩個空間介面觀察器，其中一個是包含在另一個中。</span><span class="sxs-lookup"><span data-stu-id="caa99-291">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="caa99-292">較大的音量是球形，並遵循使用者「延遲」;只有在必要時才會移動，以確保其中心是在使用者的2.0 計量內。</span><span class="sxs-lookup"><span data-stu-id="caa99-292">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its center is within 2.0 meters of the user.</span></span>
* <span data-ttu-id="caa99-293">新的和更新的空間介面網格一律會從較小的內部介面觀察器進行處理，但是網格會被快取，直到從較大的外部介面觀察器消失為止。</span><span class="sxs-lookup"><span data-stu-id="caa99-293">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="caa99-294">這可讓應用程式避免因本機使用者移動而處理許多多餘的變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-294">This allows the application to avoid processing many redundant changes because of local user movement.</span></span>
* <span data-ttu-id="caa99-295">由於空間介面可能會因為追蹤遺失而暫時消失，因此應用程式也會在追蹤遺失期間延遲捨棄移除的空間表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-295">Since a spatial surface may also disappear temporarily because of tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="caa99-296">一般而言，應用程式應該評估減少更新處理與記憶體使用量增加之間的取捨，以判斷其理想的快取策略。</span><span class="sxs-lookup"><span data-stu-id="caa99-296">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="caa99-297">轉譯</span><span class="sxs-lookup"><span data-stu-id="caa99-297">Rendering</span></span>

<span data-ttu-id="caa99-298">空間對應網格通常用於轉譯的主要方式有三種：</span><span class="sxs-lookup"><span data-stu-id="caa99-298">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="caa99-299">介面視覺效果</span><span class="sxs-lookup"><span data-stu-id="caa99-299">For surface visualization</span></span>
   * <span data-ttu-id="caa99-300">直接視覺化空間介面通常很有用。</span><span class="sxs-lookup"><span data-stu-id="caa99-300">It's often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="caa99-301">例如，將「陰影」從物件轉換成空間介面，可在將影像放在表面上時，為使用者提供實用的視覺效果意見反應。</span><span class="sxs-lookup"><span data-stu-id="caa99-301">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they're placing holograms on surfaces.</span></span>
   * <span data-ttu-id="caa99-302">有一點要注意的是，空間網格與3D 演出者可能建立的網格類型不同。</span><span class="sxs-lookup"><span data-stu-id="caa99-302">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="caa99-303">三角形拓撲不會像人類建立的拓撲一樣成為「乾淨」，而網格將會因 [各種錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality)而受到影響。</span><span class="sxs-lookup"><span data-stu-id="caa99-303">The triangle topology won't be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="caa99-304">若要建立美觀的視覺效果美觀，您可能會想要進行一些 [網格處理](spatial-mapping.md#mesh-processing)，例如填滿孔或平滑表面法線。</span><span class="sxs-lookup"><span data-stu-id="caa99-304">To create a pleasing visual aesthetic, you may want to do some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="caa99-305">您也可能想要使用著色器將演出者設計的材質投影到您的網狀架構，而不是直接視覺化網格拓朴和法線。</span><span class="sxs-lookup"><span data-stu-id="caa99-305">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="caa99-306">適用于真實世界表面的遮蔽全息</span><span class="sxs-lookup"><span data-stu-id="caa99-306">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="caa99-307">空間介面可以在深度專用階段中轉譯，只會影響 [深度緩衝區](/windows/win32/direct3d9/depth-buffers) ，而不會影響色彩呈現目標。</span><span class="sxs-lookup"><span data-stu-id="caa99-307">Spatial surfaces can be rendered in a depth-only pass, which only affects the [depth buffer](/windows/win32/direct3d9/depth-buffers) and doesn't affect color render targets.</span></span>
   * <span data-ttu-id="caa99-308">這會質數深度緩衝區，以遮蔽後續呈現空間介面背後的全像投影。</span><span class="sxs-lookup"><span data-stu-id="caa99-308">This primes the depth buffer to occlude subsequently rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="caa99-309">確切的全像遮蔽，可增強全像是在使用者的實體空間內真正存在的全像的意義。</span><span class="sxs-lookup"><span data-stu-id="caa99-309">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="caa99-310">若要啟用深度呈現，請更新您的 blend 狀態，以將所有色彩呈現目標的 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 設為零。</span><span class="sxs-lookup"><span data-stu-id="caa99-310">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) to zero for all color render targets.</span></span>
* <span data-ttu-id="caa99-311">用於修改實際表面的全像 pixels occluded 影像外觀</span><span class="sxs-lookup"><span data-stu-id="caa99-311">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="caa99-312">Pixels occluded 時，通常會隱藏呈現的幾何。</span><span class="sxs-lookup"><span data-stu-id="caa99-312">Normally rendered geometry is hidden when it's occluded.</span></span> <span data-ttu-id="caa99-313">這是藉由將深度樣板狀態中的深度函 [式](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 設定為「小於或等於」來達成，這會使幾何只有在比先前轉譯的幾何 **更接近** 相機的位置才可見。</span><span class="sxs-lookup"><span data-stu-id="caa99-313">This is achieved by setting the depth function in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) to "less than or equal", which causes geometry to be visible only where it's **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="caa99-314">不過，將某些幾何保持 pixels occluded，以及在 pixels occluded 為提供視覺回饋給使用者的方式時修改其外觀可能會很有用。</span><span class="sxs-lookup"><span data-stu-id="caa99-314">However, it may be useful to keep certain geometry visible even when it's occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="caa99-315">例如，這可讓應用程式向使用者顯示物件的位置，同時讓它清楚地顯示在真實世界表面的背後。</span><span class="sxs-lookup"><span data-stu-id="caa99-315">For example, this allows the application to show the user the location of an object while making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="caa99-316">若要達到此目的，請使用不同的著色器，以建立所需的「pixels occluded」外觀來第二次轉譯幾何。</span><span class="sxs-lookup"><span data-stu-id="caa99-316">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="caa99-317">第二次轉譯幾何之前，請對您的 [深度樣板狀態](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)進行兩個變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-317">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="caa99-318">首先，將深度函式設定為 [大於或等於]，如此一來，就只會顯示幾何與所有先前轉譯之幾何 **更遠** 的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-318">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it's **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="caa99-319">其次，將 DepthWriteMask 設定為零，如此就不會修改深度緩衝區， (深度緩衝區應繼續表示 **最接近** 相機) 的幾何深度。</span><span class="sxs-lookup"><span data-stu-id="caa99-319">Second, set the DepthWriteMask to zero, so that the depth buffer won't be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="caa99-320">轉譯空間對應網格時，[效能](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)是很重要的考慮。</span><span class="sxs-lookup"><span data-stu-id="caa99-320">[Performance](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="caa99-321">以下是轉譯空間對應網格專用的一些轉譯效能技術：</span><span class="sxs-lookup"><span data-stu-id="caa99-321">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="caa99-322">調整三角形密度</span><span class="sxs-lookup"><span data-stu-id="caa99-322">Adjust triangle density</span></span>
   * <span data-ttu-id="caa99-323">當您從介面觀察器要求空間介面網格時，請要求可滿足您需求的最小的三角形網格密度。</span><span class="sxs-lookup"><span data-stu-id="caa99-323">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="caa99-324">視介面與使用者的距離，以及其與使用者體驗的關聯性而定，可能會有意義地依據介面變化三角形密度。</span><span class="sxs-lookup"><span data-stu-id="caa99-324">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="caa99-325">減少三角形計數將會降低 GPU 上的記憶體使用量和頂點處理成本，但不會影響圖元處理成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-325">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it won't affect pixel processing costs.</span></span>
* <span data-ttu-id="caa99-326">使用截錐剔除</span><span class="sxs-lookup"><span data-stu-id="caa99-326">Use frustum culling</span></span>
   * <span data-ttu-id="caa99-327">如果您不是在目前的顯示中，則會將 [已被剔除] 剔除略過繪圖物件。</span><span class="sxs-lookup"><span data-stu-id="caa99-327">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="caa99-328">這可降低 CPU 和 GPU 的處理成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-328">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="caa99-329">由於會對每個網狀架構執行剔除，而空間介面可能很大，因此將每個空間介面網格分成較小的區塊，可能會導致更有效率的剔除 (在) 中呈現較少的三角形。</span><span class="sxs-lookup"><span data-stu-id="caa99-329">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="caa99-330">但是，您擁有的網格越多，您必須進行的繪製呼叫越多，就會增加 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-330">There's a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="caa99-331">在極端情況下，以錐剔除計算本身甚至可以有可測量的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-331">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="caa99-332">調整轉譯順序</span><span class="sxs-lookup"><span data-stu-id="caa99-332">Adjust rendering order</span></span>
   * <span data-ttu-id="caa99-333">空間表面通常很大，因為它們代表使用者在周圍的整個環境。</span><span class="sxs-lookup"><span data-stu-id="caa99-333">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="caa99-334">GPU 上的圖元處理成本可能很高，特別是在有多個可見幾何的層級 (包括空間表面和其他全像) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-334">Pixel processing costs on the GPU can be high, especially in cases where there's more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="caa99-335">在此情況下，最接近使用者的圖層將會進一步遮蔽任何層級，因此任何花費在更遠距離圖層的 GPU 時間都不會浪費。</span><span class="sxs-lookup"><span data-stu-id="caa99-335">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="caa99-336">若要減少 GPU 上的這項重複工作，最好先將不透明的表面轉譯 (更接近的介面，最後) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-336">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="caa99-337">「不透明」是指在 [深度樣板狀態](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)中，DepthWriteMask 設定為一個的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-337">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="caa99-338">轉譯最接近的介面時，它們會將深度緩衝區質數，讓 GPU 上的圖元處理器可以有效率地略過更遠的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-338">When the nearest surfaces are rendered, they'll prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="caa99-339">網格處理</span><span class="sxs-lookup"><span data-stu-id="caa99-339">Mesh Processing</span></span>

<span data-ttu-id="caa99-340">應用程式可能會想要在空間介面網格上進行 [各種作業](spatial-mapping.md#mesh-processing) ，以符合其需求。</span><span class="sxs-lookup"><span data-stu-id="caa99-340">An application may want to do [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="caa99-341">每個空間介面網格所提供的索引和頂點資料，會使用與用來呈現所有新式轉譯 Api 中三角形網格的 [頂點和索引緩衝區](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 相同的熟悉版面配置。</span><span class="sxs-lookup"><span data-stu-id="caa99-341">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="caa99-342">不過，有一個要注意的關鍵事實是，空間對應三角形有 **正面的纏繞順序**。</span><span class="sxs-lookup"><span data-stu-id="caa99-342">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="caa99-343">每個三角形都是以網格的索引緩衝區中的三個頂點索引來表示，而這些索引將會在從 **前端** 看到三角形時，以 **順** 向順序識別三角形的頂點。</span><span class="sxs-lookup"><span data-stu-id="caa99-343">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="caa99-344">空間介面網格的前端 (或外) ，會與您預期的正面 (可見的真實世界表面) 相同。</span><span class="sxs-lookup"><span data-stu-id="caa99-344">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="caa99-345">如果介面觀察器所提供的最粗略三角形密度仍能力不佳粗略，則應用程式應該只進行網格簡化，這項工作的計算成本很高，而且已經由執行時間執行，以產生各種提供的詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="caa99-345">Applications should only do mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="caa99-346">由於每個介面觀察者都可以提供多個未連接的空間介面，因此有些應用程式可能會想要彼此裁剪這些空間介面網格，然後將它們 zipper 在一起。</span><span class="sxs-lookup"><span data-stu-id="caa99-346">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="caa99-347">一般情況下，裁剪步驟是必要的，因為鄰近的空間介面網格通常會稍微重迭。</span><span class="sxs-lookup"><span data-stu-id="caa99-347">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="caa99-348">Raycasting 和碰撞</span><span class="sxs-lookup"><span data-stu-id="caa99-348">Raycasting and Collision</span></span>

<span data-ttu-id="caa99-349">為了讓物理 API (例如 [Havok](https://www.havok.com/)) 為應用程式提供空間介面的 raycasting 和碰撞功能，應用程式必須提供空間介面網格給物理 api。</span><span class="sxs-lookup"><span data-stu-id="caa99-349">In order for a physics API (such as [Havok](https://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="caa99-350">用於物理的網格通常具有下列屬性：</span><span class="sxs-lookup"><span data-stu-id="caa99-350">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="caa99-351">它們只包含少量的三角形。</span><span class="sxs-lookup"><span data-stu-id="caa99-351">They contain only small numbers of triangles.</span></span> <span data-ttu-id="caa99-352">物理運算比轉譯作業更耗費計算。</span><span class="sxs-lookup"><span data-stu-id="caa99-352">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="caa99-353">它們是「水緊密型」。</span><span class="sxs-lookup"><span data-stu-id="caa99-353">They're 'water-tight'.</span></span> <span data-ttu-id="caa99-354">預期為穩固的表面不應該有小洞;即使漏洞太小而無法顯示，也會造成問題。</span><span class="sxs-lookup"><span data-stu-id="caa99-354">Surfaces intended to be solid shouldn't have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="caa99-355">它們會轉換成凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="caa99-355">They're converted into convex hulls.</span></span> <span data-ttu-id="caa99-356">凸 hulls 有很少的多邊形，而且沒有孔洞，而且比原始三角形網格更能有效率地處理這些空間。</span><span class="sxs-lookup"><span data-stu-id="caa99-356">Convex hulls have few polygons and are free of holes, and they're much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="caa99-357">針對空間介面進行 raycasts 時，請記住，這些表面通常很複雜，雜亂的圖形幾乎不會有很大的細節，就像您的辦公桌一樣！</span><span class="sxs-lookup"><span data-stu-id="caa99-357">When doing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="caa99-358">這表示單一 raycast 通常不足以提供您足夠的資訊，讓您瞭解表面的形狀，以及附近的空白空間的形狀。</span><span class="sxs-lookup"><span data-stu-id="caa99-358">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="caa99-359">在社區域內執行許多 raycasts，以及使用匯總結果來更可靠地瞭解介面，通常是個不錯的主意。</span><span class="sxs-lookup"><span data-stu-id="caa99-359">It's usually a good idea to do many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="caa99-360">例如，使用10個 raycasts 的平均值來引導表面上的全像影像放置，將會產生更平滑且較不只使用單一 raycast 的「抖動」結果。</span><span class="sxs-lookup"><span data-stu-id="caa99-360">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="caa99-361">不過，請記住，每個 raycast 可能會有較高的計算成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-361">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="caa99-362">視您的使用案例而定，您應該權衡額外 raycasts 的計算成本 (完成每個) 畫面格的 [計算成本，以平滑](spatial-mapping.md#mesh-processing) 和移除空間介面中的漏洞 (在空間網格更新) 時完成。</span><span class="sxs-lookup"><span data-stu-id="caa99-362">Depending on your usage scenario, you should trade off the computational cost of extra raycasts (done every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (done when spatial meshes are updated).</span></span>

## <a name="the-environment-scanning-experience"></a><span data-ttu-id="caa99-363">環境掃描體驗</span><span class="sxs-lookup"><span data-stu-id="caa99-363">The environment scanning experience</span></span>

<span data-ttu-id="caa99-364">使用空間對應的每個應用程式都應該考慮提供「掃描體驗」;應用程式會透過此程式引導使用者掃描應用程式正常運作所需的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-364">Each application that uses spatial mapping should consider providing a 'scanning experience'; the process through which the application guides the user to scan surfaces that are necessary for the application to function correctly.</span></span>

<span data-ttu-id="caa99-365">![掃描範例](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span><span class="sxs-lookup"><span data-stu-id="caa99-365">![Example of scanning](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span></span><br>
<span data-ttu-id="caa99-366">*掃描範例*</span><span class="sxs-lookup"><span data-stu-id="caa99-366">*Example of scanning*</span></span>

<span data-ttu-id="caa99-367">這種掃描體驗的本質可能會隨著每個應用程式的需求而有很大的差異，但有兩個主要原則應該引導其設計。</span><span class="sxs-lookup"><span data-stu-id="caa99-367">The nature of this scanning experience can vary greatly depending upon each application's needs, but two main principles should guide its design.</span></span>

<span data-ttu-id="caa99-368">首先， **與使用者進行清楚的通訊是主要考慮**。</span><span class="sxs-lookup"><span data-stu-id="caa99-368">Firstly, **clear communication with the user is the primary concern**.</span></span> <span data-ttu-id="caa99-369">使用者應該一律留意是否符合應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="caa99-369">The user should always be aware of whether the application's requirements are being met.</span></span> <span data-ttu-id="caa99-370">當它們不符合時，就應該立即清楚清楚使用者的原因，而且應該很快就會採取適當的動作。</span><span class="sxs-lookup"><span data-stu-id="caa99-370">When they aren't being met, it should be immediately clear to the user why this is so and they should be quickly led to take the appropriate action.</span></span>

<span data-ttu-id="caa99-371">其次， **應用程式應該嘗試在效率與可靠性之間取得平衡**。</span><span class="sxs-lookup"><span data-stu-id="caa99-371">Secondly, **applications should attempt to strike a balance between efficiency and reliability**.</span></span> <span data-ttu-id="caa99-372">如果可以 **可靠地** 這麼做，應用程式應該會自動分析空間對應資料，以節省使用者的時間。</span><span class="sxs-lookup"><span data-stu-id="caa99-372">When it's possible to do so **reliably**, applications should automatically analyze spatial mapping data to save the user time.</span></span> <span data-ttu-id="caa99-373">如果無法可靠地這麼做，應用程式應該改為讓使用者快速提供應用程式所需的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="caa99-373">When it isn't possible to do so reliably, applications should instead enable the user to quickly provide the application with the additional information it requires.</span></span>

<span data-ttu-id="caa99-374">為了協助設計正確的掃描體驗，請考慮下列哪一個可能適用于您的應用程式：</span><span class="sxs-lookup"><span data-stu-id="caa99-374">To help design the right scanning experience, consider which of the following possibilities are applicable to your application:</span></span>

* <span data-ttu-id="caa99-375">**沒有掃描體驗**</span><span class="sxs-lookup"><span data-stu-id="caa99-375">**No scanning experience**</span></span>
   * <span data-ttu-id="caa99-376">應用程式在沒有任何引導式掃描體驗的情況下可以完美運作;它會瞭解在自然使用者移動過程中觀察到的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-376">An application may function perfectly without any guided scanning experience; it will learn about surfaces that are observed in the course of natural user movement.</span></span>
   * <span data-ttu-id="caa99-377">例如，讓使用者在具有全像油漆油漆的表面上繪製的應用程式，只需要知道使用者目前可見的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-377">For example, an application that lets the user draw on surfaces with holographic spray paint requires knowledge only of the surfaces currently visible to the user.</span></span>
   * <span data-ttu-id="caa99-378">如果環境是使用者已使用 HoloLens 花了很多時間，則可能會掃描環境。</span><span class="sxs-lookup"><span data-stu-id="caa99-378">The environment may be scanned already if it's one in which the user has already spent lots of time using the HoloLens.</span></span>
   * <span data-ttu-id="caa99-379">請記住，空間對應所使用的相機只能在使用者前方看到 3.1 m，因此空間對應將不會知道任何較遠的表面，除非使用者從較接近的距離觀察到它們。</span><span class="sxs-lookup"><span data-stu-id="caa99-379">Bear in mind however that the camera used by spatial mapping can only see 3.1 m in front of the user, so spatial mapping won't know about any more distant surfaces unless the user has observed them from a closer distance in the past.</span></span>
   * <span data-ttu-id="caa99-380">因此，使用者瞭解哪些表面已經過掃描，應用程式應該提供視覺效果回饋給這個效果，例如，將虛擬遮蔽轉換成掃描的表面，可能有助於使用者將影像放在這些表面上。</span><span class="sxs-lookup"><span data-stu-id="caa99-380">So the user understands which surfaces have been scanned, the application should provide visual feedback to this effect, for example casting virtual shadows onto scanned surfaces may help the user place holograms on those surfaces.</span></span>
   * <span data-ttu-id="caa99-381">在此情況下，應該將每個畫面格的空間介面觀察器界限磁片區更新為主體鎖定的 [空間座標系統](coordinate-systems.md)，使其符合使用者的限制。</span><span class="sxs-lookup"><span data-stu-id="caa99-381">For this case, the spatial surface observer's bounding volumes should be updated each frame to a body-locked [spatial coordinate system](coordinate-systems.md), so that they follow the user.</span></span>

* <span data-ttu-id="caa99-382">**尋找適當的位置**</span><span class="sxs-lookup"><span data-stu-id="caa99-382">**Find a suitable location**</span></span>
   * <span data-ttu-id="caa99-383">應用程式的設計可用於具有特定需求的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-383">An application may be designed for use in a location with specific requirements.</span></span>
   * <span data-ttu-id="caa99-384">例如，應用程式可能需要使用者的空白區域，讓他們可以安全地實務 kung-fu。</span><span class="sxs-lookup"><span data-stu-id="caa99-384">For example, the application may require an empty area around the user so they can safely practice holographic kung-fu.</span></span>
   * <span data-ttu-id="caa99-385">應用程式應該將任何特定需求傳達給使用者，並以清楚的視覺效果回饋來強化。</span><span class="sxs-lookup"><span data-stu-id="caa99-385">Applications should communicate any specific requirements to the user up-front, and reinforce them with clear visual feedback.</span></span>
   * <span data-ttu-id="caa99-386">在此範例中，應用程式應該將所需空白區域的範圍視覺化，並以視覺化方式醒目提示此區域內任何不想要的物件是否存在。</span><span class="sxs-lookup"><span data-stu-id="caa99-386">In this example, the application should visualize the extent of the required empty area and visually highlight the presence of any undesired objects within this zone.</span></span>
   * <span data-ttu-id="caa99-387">在此情況下，空間介面觀察者的周框磁片區應在選擇的位置使用世界鎖定的 [空間座標系統](coordinate-systems.md) 。</span><span class="sxs-lookup"><span data-stu-id="caa99-387">For this case, the spatial surface observer's bounding volumes should use a world-locked [spatial coordinate system](coordinate-systems.md) in the chosen location.</span></span>

* <span data-ttu-id="caa99-388">**尋找適合的表面設定**</span><span class="sxs-lookup"><span data-stu-id="caa99-388">**Find a suitable configuration of surfaces**</span></span>
   * <span data-ttu-id="caa99-389">應用程式可能需要特定的介面設定，例如兩個大型、平坦的牆，以建立一個全像的鏡像廳。</span><span class="sxs-lookup"><span data-stu-id="caa99-389">An application may require a specific configuration of surfaces, for example two large, flat, opposing walls to create a holographic hall of mirrors.</span></span>
   * <span data-ttu-id="caa99-390">在這種情況下，應用程式將需要分析空間對應所提供的介面，以偵測適當的表面，並將使用者導向至這些介面。</span><span class="sxs-lookup"><span data-stu-id="caa99-390">In such cases, the application will need to analyze the surfaces provided by spatial mapping to detect suitable surfaces, and direct the user toward them.</span></span>
   * <span data-ttu-id="caa99-391">如果應用程式的介面分析不可靠，則使用者應該有一個 [回復] 選項。</span><span class="sxs-lookup"><span data-stu-id="caa99-391">The user should have a fallback option if the application's surface analysis isn't reliable.</span></span> <span data-ttu-id="caa99-392">例如，如果應用程式不正確地將門口識別為平面，則使用者需要簡單的方法來修正此錯誤。</span><span class="sxs-lookup"><span data-stu-id="caa99-392">For example, if the application incorrectly identifies a doorway as a flat wall, the user needs a simple way to correct this error.</span></span>

* <span data-ttu-id="caa99-393">**掃描部分環境**</span><span class="sxs-lookup"><span data-stu-id="caa99-393">**Scan part of the environment**</span></span>
   * <span data-ttu-id="caa99-394">應用程式可能會想要根據使用者的指示，只捕獲部分的環境。</span><span class="sxs-lookup"><span data-stu-id="caa99-394">An application may wish to only capture part of the environment, as directed by the user.</span></span>
   * <span data-ttu-id="caa99-395">例如，應用程式會掃描房間內的一部分，讓使用者可以針對想要銷售的傢俱張貼全像已分類的廣告。</span><span class="sxs-lookup"><span data-stu-id="caa99-395">For example, the application scans part of a room so the user may post a holographic classified ad for furniture they wish to sell.</span></span>
   * <span data-ttu-id="caa99-396">在此情況下，應用程式應該在使用者掃描期間，于使用者觀察到的區域內，捕捉空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="caa99-396">In this case, the application should capture spatial mapping data within the regions observed by the user during their scan.</span></span>

* <span data-ttu-id="caa99-397">**掃描整個聊天室**</span><span class="sxs-lookup"><span data-stu-id="caa99-397">**Scan the whole room**</span></span>
   * <span data-ttu-id="caa99-398">應用程式可能需要掃描目前房間中的所有表面，包括使用者背後的所有表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-398">An application may require a scan of all of the surfaces in the current room, including those behind the user.</span></span>
   * <span data-ttu-id="caa99-399">例如，遊戲可能會將使用者置於 Gulliver 的角色中，從數百個從所有方向接近的微小 Lilliputians siege。</span><span class="sxs-lookup"><span data-stu-id="caa99-399">For example, a game may put the user in the role of Gulliver, under siege from hundreds of tiny Lilliputians approaching from all directions.</span></span>
   * <span data-ttu-id="caa99-400">在這種情況下，應用程式必須判斷目前空間中已掃描的表面數量，並指示使用者的注視填滿顯著的間隙。</span><span class="sxs-lookup"><span data-stu-id="caa99-400">In such cases, the application will need to determine how many of the surfaces in the current room have already been scanned, and direct the user's gaze to fill in significant gaps.</span></span>
   * <span data-ttu-id="caa99-401">此程式的關鍵是提供視覺回饋，讓使用者清楚知道尚未掃描哪些表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-401">The key to this process is providing visual feedback that makes it clear to the user which surfaces haven't yet been scanned.</span></span> <span data-ttu-id="caa99-402">例如，應用程式可以使用以 [距離為基礎的霧化](/windows/win32/direct3d9/fog-formulas) ，以視覺方式反白顯示空間對應介面未涵蓋的區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-402">The application could, for example,  use [distance-based fog](/windows/win32/direct3d9/fog-formulas) to visually highlight regions that aren't covered by spatial mapping surfaces.</span></span>

* <span data-ttu-id="caa99-403">**取得環境的初始快照集**</span><span class="sxs-lookup"><span data-stu-id="caa99-403">**Take an initial snapshot of the environment**</span></span>
   * <span data-ttu-id="caa99-404">在取得初始「快照集」之後，應用程式可能會想要忽略環境中的所有變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-404">An application may wish to ignore all changes in the environment after taking an initial 'snapshot'.</span></span>
   * <span data-ttu-id="caa99-405">這可能適用于避免與環境的初始狀態緊密結合的使用者建立資料中斷。</span><span class="sxs-lookup"><span data-stu-id="caa99-405">This may be appropriate to avoid disruption of user-created data that is tightly coupled to the initial state of the environment.</span></span>
   * <span data-ttu-id="caa99-406">在此情況下，應用程式應該在掃描完成後，以初始狀態建立空間對應資料的複本。</span><span class="sxs-lookup"><span data-stu-id="caa99-406">In this case, the application should make a copy of the spatial mapping data in its initial state once the scan is complete.</span></span>
   * <span data-ttu-id="caa99-407">如果環境仍能正確地 pixels occluded 全像影像，應用程式應該會繼續接收空間對應資料的更新。</span><span class="sxs-lookup"><span data-stu-id="caa99-407">Applications should continue receiving updates to spatial mapping data if holograms are still to be correctly occluded by the environment.</span></span>
   * <span data-ttu-id="caa99-408">空間對應資料的持續更新也可讓您視覺化已發生的任何變更，將環境的先前與目前狀態之間的差異向使用者闡明。</span><span class="sxs-lookup"><span data-stu-id="caa99-408">Continued updates to spatial mapping data also allow visualizing any changes that have occurred, clarifying to the user the differences between prior and present states of the environment.</span></span>

* <span data-ttu-id="caa99-409">**採用使用者起始的環境快照集**</span><span class="sxs-lookup"><span data-stu-id="caa99-409">**Take user-initiated snapshots of the environment**</span></span>
   * <span data-ttu-id="caa99-410">應用程式可能只會在使用者指示時，想要回應環境變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-410">An application may only wish to respond to environmental changes when instructed by the user.</span></span>
   * <span data-ttu-id="caa99-411">例如，使用者可以在不同的時間捕捉其姿勢，藉以建立多個「friend」的「statues」。</span><span class="sxs-lookup"><span data-stu-id="caa99-411">For example, the user could create multiple 3D 'statues' of a friend by capturing their poses at different moments.</span></span>

* <span data-ttu-id="caa99-412">**允許使用者變更環境**</span><span class="sxs-lookup"><span data-stu-id="caa99-412">**Allow the user to change the environment**</span></span>
   * <span data-ttu-id="caa99-413">應用程式可能設計為即時回應使用者環境中所做的任何變更。</span><span class="sxs-lookup"><span data-stu-id="caa99-413">An application may be designed to respond in real time to any changes made in the user's environment.</span></span>
   * <span data-ttu-id="caa99-414">例如，使用者繪圖 curtain 可能會觸發「場景變更」，以進行另一端的全像 play。</span><span class="sxs-lookup"><span data-stu-id="caa99-414">For example, the user drawing a curtain could trigger 'scene change' for a holographic play taking place on the other side.</span></span>

* <span data-ttu-id="caa99-415">**引導使用者避免空間對應資料中的錯誤**</span><span class="sxs-lookup"><span data-stu-id="caa99-415">**Guide the user to avoid errors in the spatial mapping data**</span></span>
   * <span data-ttu-id="caa99-416">應用程式可能會想要在掃描其環境時，為使用者提供指引。</span><span class="sxs-lookup"><span data-stu-id="caa99-416">An application may wish to provide guidance to the user while they're scanning their environment.</span></span>
   * <span data-ttu-id="caa99-417">這可協助使用者避免 [空間對應資料中](spatial-mapping.md#what-influences-spatial-mapping-quality)發生特定類型的錯誤，例如，離開 sunlit 視窗或鏡像。</span><span class="sxs-lookup"><span data-stu-id="caa99-417">This can help the user to avoid certain kinds of [errors in the spatial mapping data](spatial-mapping.md#what-influences-spatial-mapping-quality), for example by staying away from sunlit windows or mirrors.</span></span>

<span data-ttu-id="caa99-418">有一個要注意的額外詳細資料，是空間對應資料的「範圍」不是無限的。</span><span class="sxs-lookup"><span data-stu-id="caa99-418">One extra detail to be aware of is that the 'range' of spatial mapping data isn't unlimited.</span></span> <span data-ttu-id="caa99-419">雖然空間對應確實會建立大量的永久資料庫，但它只會讓使用者以有限大小的「反升」方式提供資料給應用程式。</span><span class="sxs-lookup"><span data-stu-id="caa99-419">While spatial mapping does build a permanent database of large spaces, it only makes that data available to applications in a 'bubble' of limited size around the user.</span></span> <span data-ttu-id="caa99-420">如果您從長 corridor 的開頭開始，並從一開始就到達足夠的位置，則最後的空間表面將會消失。</span><span class="sxs-lookup"><span data-stu-id="caa99-420">If you start at the beginning of a long corridor and walk far enough away from the start, then eventually the spatial surfaces back at the beginning will disappear.</span></span> <span data-ttu-id="caa99-421">您可以在應用程式中從可用空間對應資料消失之後，將這些表面快取，藉以減輕此問題。</span><span class="sxs-lookup"><span data-stu-id="caa99-421">You can mitigate this by caching those surfaces in your application after they've disappeared from the available spatial mapping data.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="caa99-422">網格處理</span><span class="sxs-lookup"><span data-stu-id="caa99-422">Mesh processing</span></span>

<span data-ttu-id="caa99-423">它可能有助於偵測介面中常見的錯誤類型，並視需要篩選、移除或修改空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="caa99-423">It may help to detect common types of errors in surfaces and to filter, remove or modify the spatial mapping data as appropriate.</span></span>

<span data-ttu-id="caa99-424">請記住，空間對應資料的預期會盡可能忠實呈現到真實世界的表面，因此，您所套用的任何處理都會將您的介面從「真」進一步改變。</span><span class="sxs-lookup"><span data-stu-id="caa99-424">Bear in mind that spatial mapping data is intended to be as faithful as possible to real-world surfaces, so any processing you apply risks shifting your surfaces further from the 'truth'.</span></span>

<span data-ttu-id="caa99-425">以下是一些您可能會覺得有用的不同網格處理類型範例：</span><span class="sxs-lookup"><span data-stu-id="caa99-425">Here are some examples of different types of mesh processing that you may find useful:</span></span>

* <span data-ttu-id="caa99-426">**孔填滿**</span><span class="sxs-lookup"><span data-stu-id="caa99-426">**Hole filling**</span></span>
   * <span data-ttu-id="caa99-427">如果有深色材質的小型物件無法掃描，它就會在周圍表面留下洞。</span><span class="sxs-lookup"><span data-stu-id="caa99-427">If a small object made of a dark material fails to scan, it will leave a hole in the surrounding surface.</span></span>
   * <span data-ttu-id="caa99-428">孔會影響遮蔽：在被視為不透明的真實世界表面中，可以看到「全像」。</span><span class="sxs-lookup"><span data-stu-id="caa99-428">Holes affect occlusion: holograms can be seen 'through' a hole in a supposedly opaque real-world surface.</span></span>
   * <span data-ttu-id="caa99-429">漏洞會影響 raycasts：如果您使用 raycasts 來協助使用者與表面互動，則這些光線可能不需要通過漏洞。</span><span class="sxs-lookup"><span data-stu-id="caa99-429">Holes affect raycasts: if you're using raycasts to help users interact with surfaces, it may be undesirable for these rays to pass through holes.</span></span> <span data-ttu-id="caa99-430">其中一個緩和措施是使用多個 raycasts 的組合，其中涵蓋適當大小的區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-430">One mitigation is to use a bundle of multiple raycasts covering an appropriately sized region.</span></span> <span data-ttu-id="caa99-431">這可讓您篩選「極端的」結果，如此一來即使某個 raycast 通過小洞，匯總結果仍會有效。</span><span class="sxs-lookup"><span data-stu-id="caa99-431">This will allow you to filter 'outlier' results, so that even if one raycast passes through a small hole, the aggregate result will still be valid.</span></span> <span data-ttu-id="caa99-432">不過，這種方法會產生計算成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-432">However, this approach comes at a computational cost.</span></span>
   * <span data-ttu-id="caa99-433">孔會影響物理衝突：物理模擬所控制的物件可能會在樓層中下降，並會遺失。</span><span class="sxs-lookup"><span data-stu-id="caa99-433">Holes affect physics collisions: an object controlled by physics simulation may drop through a hole in the floor and become lost.</span></span>
   * <span data-ttu-id="caa99-434">您可以在表面網格中演算法填滿這類漏洞。</span><span class="sxs-lookup"><span data-stu-id="caa99-434">It's possible to algorithmically fill such holes in the surface mesh.</span></span> <span data-ttu-id="caa99-435">不過，您必須調整演算法，讓「真實漏洞」（例如 windows 和門口）不會被填入。</span><span class="sxs-lookup"><span data-stu-id="caa99-435">However, you'll need to tune your algorithm so that 'real holes' such as windows and doorways don't get filled in.</span></span> <span data-ttu-id="caa99-436">可能很難可靠地區分「真實漏洞」與「虛漏洞」，因此您必須試驗不同的啟發學習法，例如「大小」和「界限圖形」。</span><span class="sxs-lookup"><span data-stu-id="caa99-436">It can be difficult to reliably differentiate 'real holes' from 'imaginary holes', so you'll need to experiment with different heuristics such as 'size' and 'boundary shape'.</span></span>

* <span data-ttu-id="caa99-437">**Hallucination 移除**</span><span class="sxs-lookup"><span data-stu-id="caa99-437">**Hallucination removal**</span></span>
   * <span data-ttu-id="caa99-438">反射、亮燈和移動物件可能會將小型的延遲 ' hallucinations ' 浮在中。</span><span class="sxs-lookup"><span data-stu-id="caa99-438">Reflections, bright lights, and moving objects can leave small lingering 'hallucinations' floating in mid-air.</span></span>
   * <span data-ttu-id="caa99-439">Hallucinations 會影響遮蔽： Hallucinations 可能會顯示為在前方移動的深色圖形，以及遮蔽其他的全像投影。</span><span class="sxs-lookup"><span data-stu-id="caa99-439">Hallucinations affect occlusion: hallucinations may become visible as dark shapes moving in front of and occluding other holograms.</span></span>
   * <span data-ttu-id="caa99-440">Hallucinations 會影響 raycasts：如果您使用 raycasts 來協助使用者與介面互動，則這些光線可能會叫用 hallucination 而非其背後的表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-440">Hallucinations affect raycasts: if you're using raycasts to help users interact with surfaces, these rays could hit a hallucination instead of the surface behind it.</span></span> <span data-ttu-id="caa99-441">和漏洞一樣，有一個緩和措施是使用許多 raycasts，而不是單一 raycast，但同樣地，這會產生計算成本。</span><span class="sxs-lookup"><span data-stu-id="caa99-441">As with holes, one mitigation is to use many raycasts instead of a single raycast, but again this will come at a computational cost.</span></span>
   * <span data-ttu-id="caa99-442">Hallucinations 會影響物理衝突：物理模擬所控制的物件可能會停滯于 hallucination，而且無法在看似清楚的空間區域內移動。</span><span class="sxs-lookup"><span data-stu-id="caa99-442">Hallucinations affect physics collisions: an object controlled by physics simulation may become stuck against a hallucination and be unable to move through a seemingly clear area of space.</span></span>
   * <span data-ttu-id="caa99-443">您可以從介面網格篩選這類 hallucinations。</span><span class="sxs-lookup"><span data-stu-id="caa99-443">It's possible to filter such hallucinations from the surface mesh.</span></span> <span data-ttu-id="caa99-444">不過，如同漏洞，您將需要調整演算法，如此一來，就不會移除實際的小型物件，例如燈光表示和大門把手。</span><span class="sxs-lookup"><span data-stu-id="caa99-444">However, as with holes, you'll need to tune your algorithm so that real small objects such as lamp-stands and door handles don't get removed.</span></span>

* <span data-ttu-id="caa99-445">**平滑處理**</span><span class="sxs-lookup"><span data-stu-id="caa99-445">**Smoothing**</span></span>
   * <span data-ttu-id="caa99-446">空間對應可能會傳回看似粗略或「雜訊」的表面，相較于其真實世界的對應專案。</span><span class="sxs-lookup"><span data-stu-id="caa99-446">Spatial mapping may return surfaces that appear to be rough or 'noisy' in comparison to their real-world counterparts.</span></span>
   * <span data-ttu-id="caa99-447">平滑度會影響物理衝突：如果地面是粗略的，則實際模擬的高爾夫球球可能無法順暢地在直線之間進行滾動。</span><span class="sxs-lookup"><span data-stu-id="caa99-447">Smoothness affects physics collisions: if the floor is rough, a physically simulated golf ball may not roll smoothly across it in a straight line.</span></span>
   * <span data-ttu-id="caa99-448">平滑會影響轉譯：如果介面是直接視覺化的，則粗略表面法線可能會影響其外觀並中斷「乾淨」外觀。</span><span class="sxs-lookup"><span data-stu-id="caa99-448">Smoothness affects rendering: if a surface is visualized directly, rough surface normals can affect its appearance and disrupt a 'clean' look.</span></span> <span data-ttu-id="caa99-449">您可以在用來呈現介面的著色器中使用適當的光源和紋理來緩和這個問題。</span><span class="sxs-lookup"><span data-stu-id="caa99-449">It's possible to mitigate this by using appropriate lighting and textures in the shader that is used to render the surface.</span></span>
   * <span data-ttu-id="caa99-450">您可以將介面網格中的粗糙度平滑。</span><span class="sxs-lookup"><span data-stu-id="caa99-450">It's possible to smooth out roughness in a surface mesh.</span></span> <span data-ttu-id="caa99-451">不過，這可能會從對應的真實世界表面中往外推出介面。</span><span class="sxs-lookup"><span data-stu-id="caa99-451">However, this may push the surface further away from the corresponding real-world surface.</span></span> <span data-ttu-id="caa99-452">若要產生準確的全像遮蔽，以及讓使用者可以與全像攝影表面進行精確且可預測的互動，請務必維持密切的對應。</span><span class="sxs-lookup"><span data-stu-id="caa99-452">Maintaining a close correspondence is important to produce accurate hologram occlusion, and to enable users to achieve precise and predictable interactions with holographic surfaces.</span></span>
   * <span data-ttu-id="caa99-453">如果只需要表面變更，可能就足以在不變更頂點位置的情況下平滑頂點法線。</span><span class="sxs-lookup"><span data-stu-id="caa99-453">If only a cosmetic change is required, it may be sufficient to smooth vertex normals without changing vertex positions.</span></span>

* <span data-ttu-id="caa99-454">**平面尋找**</span><span class="sxs-lookup"><span data-stu-id="caa99-454">**Plane finding**</span></span>
   * <span data-ttu-id="caa99-455">應用程式可能會想要在空間對應所提供的表面上執行許多形式的分析。</span><span class="sxs-lookup"><span data-stu-id="caa99-455">There are many forms of analysis that an application may wish to perform on the surfaces provided by spatial mapping.</span></span>
   * <span data-ttu-id="caa99-456">一個簡單的範例是「平面尋找」;識別表面的系結、大部分的平面區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-456">One simple example is 'plane finding'; identifying bounded, mostly planar regions of surfaces.</span></span>
   * <span data-ttu-id="caa99-457">平面區域可用來當做全像工作表面，也就是可由應用程式自動放置全息內容的區域。</span><span class="sxs-lookup"><span data-stu-id="caa99-457">Planar regions can be used as holographic work-surfaces, regions where holographic content can be automatically placed by the application.</span></span>
   * <span data-ttu-id="caa99-458">平面區域可以限制使用者介面，以引導使用者與最符合其需求的表面互動。</span><span class="sxs-lookup"><span data-stu-id="caa99-458">Planar regions can constrain the user interface, to guide users to interact with the surfaces that best suit their needs.</span></span>
   * <span data-ttu-id="caa99-459">平面區域可在真實世界中使用，適用于多功能物件（例如 LCD 螢幕、表格或白板）。</span><span class="sxs-lookup"><span data-stu-id="caa99-459">Planar regions can be used as in the real world, for holographic counterparts to functional objects such as LCD screens, tables or whiteboards.</span></span>
   * <span data-ttu-id="caa99-460">平面區域可以定義播放區域，形成影片遊戲等級的基礎。</span><span class="sxs-lookup"><span data-stu-id="caa99-460">Planar regions can define play areas, forming the basis of video game levels.</span></span>
   * <span data-ttu-id="caa99-461">平面區域可協助虛擬專員流覽真實世界，方法是找出真實人員可能進行的範圍。</span><span class="sxs-lookup"><span data-stu-id="caa99-461">Planar regions can aid virtual agents to navigate the real world, by identifying the areas of floor that real people are likely to walk on.</span></span>

## <a name="prototyping-and-debugging"></a><span data-ttu-id="caa99-462">原型設計和調試</span><span class="sxs-lookup"><span data-stu-id="caa99-462">Prototyping and debugging</span></span>

### <a name="useful-tools"></a><span data-ttu-id="caa99-463">有用的工具</span><span class="sxs-lookup"><span data-stu-id="caa99-463">Useful tools</span></span>

* <span data-ttu-id="caa99-464">[HoloLens 模擬器](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md)可以用來開發使用空間對應的應用程式，而不需要存取實體 HoloLens。</span><span class="sxs-lookup"><span data-stu-id="caa99-464">The [HoloLens emulator](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md) can be used to develop applications using spatial mapping without access to a physical HoloLens.</span></span> <span data-ttu-id="caa99-465">它可讓您在實際的環境中，使用您的應用程式通常會取用的所有資料（包括 HoloLens 動作、空間座標系統和空間對應網格）來模擬 HoloLens 上的即時會話。</span><span class="sxs-lookup"><span data-stu-id="caa99-465">It allows you to simulate a live session on a HoloLens in a realistic environment, with all of the data your application would normally consume, including HoloLens motion, spatial coordinate systems, and spatial mapping meshes.</span></span> <span data-ttu-id="caa99-466">這可以用來提供可靠、可重複的輸入，這對您的程式碼所做的變更和評估程式碼的變更可能很有用。</span><span class="sxs-lookup"><span data-stu-id="caa99-466">This can be used to provide reliable, repeatable input, which can be useful for debugging problems and evaluating changes to your code.</span></span>
* <span data-ttu-id="caa99-467">若要重現案例，請從即時 HoloLens 的網路上抓取空間對應資料，然後將它儲存至磁片，並在稍後的偵測會話中重複使用。</span><span class="sxs-lookup"><span data-stu-id="caa99-467">To reproduce a scenario, capture spatial mapping data over the network from a live HoloLens, then save it to disk and reuse it in later debugging sessions.</span></span>
* <span data-ttu-id="caa99-468">[Windows 裝置入口網站3d 視圖](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view)會提供一種方式，讓您查看目前可透過空間對應系統使用的所有空間表面。</span><span class="sxs-lookup"><span data-stu-id="caa99-468">The [Windows device portal 3D view](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view) provides a way to see all of the spatial surfaces currently available via the spatial mapping system.</span></span> <span data-ttu-id="caa99-469">這會針對應用程式內的空間表面提供比較的基礎例如，您可以輕鬆地分辨是否有任何空間表面遺失或顯示在錯誤的位置。</span><span class="sxs-lookup"><span data-stu-id="caa99-469">This provides a basis of comparison for the spatial surfaces inside your application; for example, you can easily tell if any spatial surfaces are missing or are being displayed in the wrong place.</span></span>

### <a name="general-prototyping-guidance"></a><span data-ttu-id="caa99-470">一般原型設計指導方針</span><span class="sxs-lookup"><span data-stu-id="caa99-470">General prototyping guidance</span></span>

* <span data-ttu-id="caa99-471">因為空間對應資料中的 [錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality) 可能會對您的使用者體驗造成強烈影響，所以建議您在各種環境中測試您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="caa99-471">Because [errors](spatial-mapping.md#what-influences-spatial-mapping-quality) in the spatial mapping data may strongly affect your user's experience, we recommend that you test your application in a wide variety of environments.</span></span>
* <span data-ttu-id="caa99-472">不要習慣在相同位置（例如您的辦公桌）進行永遠測試的習慣。</span><span class="sxs-lookup"><span data-stu-id="caa99-472">Don't get trapped in the habit of always testing in the same location, for example at your desk.</span></span> <span data-ttu-id="caa99-473">請務必在不同位置、圖形、大小和材質的各種表面上進行測試。</span><span class="sxs-lookup"><span data-stu-id="caa99-473">Make sure to test on various surfaces of different positions, shapes, sizes, and materials.</span></span>
* <span data-ttu-id="caa99-474">同樣地，雖然綜合或記錄的資料很適合用來進行偵錯工具，但不太依賴相同的測試案例。</span><span class="sxs-lookup"><span data-stu-id="caa99-474">Similarly, while synthetic or recorded data can be useful for debugging, don't become too reliant upon the same few test cases.</span></span> <span data-ttu-id="caa99-475">這可能會延遲尋找更多測試較早所攔截到的重要問題。</span><span class="sxs-lookup"><span data-stu-id="caa99-475">This may delay finding important issues that more varied testing would have caught earlier.</span></span>
* <span data-ttu-id="caa99-476">使用實際的 (和理想的 uncoached) 使用者進行測試是個不錯的主意，因為它們可能不會像您一樣使用 HoloLens 或您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="caa99-476">It's a good idea to perform testing with real (and ideally uncoached) users, because they may not use the HoloLens or your application in exactly the same way that you do.</span></span> <span data-ttu-id="caa99-477">事實上，這可能會令人驚訝的是，人們的行為、知識和假設可以是什麼？</span><span class="sxs-lookup"><span data-stu-id="caa99-477">In fact, it may surprise you how divergent people's behavior, knowledge, and assumptions can be!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="caa99-478">疑難排解</span><span class="sxs-lookup"><span data-stu-id="caa99-478">Troubleshooting</span></span>

* <span data-ttu-id="caa99-479">為了讓介面網格正確源，每個 GameObject 都必須在使用中，然後才會將它傳送至 SurfaceObserver，以建立其網格。</span><span class="sxs-lookup"><span data-stu-id="caa99-479">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it's sent to the SurfaceObserver to have its mesh constructed.</span></span> <span data-ttu-id="caa99-480">否則，網格會顯示在您的空間中，但以怪角度旋轉。</span><span class="sxs-lookup"><span data-stu-id="caa99-480">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="caa99-481">執行與 SurfaceObserver 通訊之腳本的 GameObject 必須設定為來源。</span><span class="sxs-lookup"><span data-stu-id="caa99-481">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="caa99-482">否則，您建立並傳送給 SurfaceObserver 的所有 Gameobject 都有其格線，其位移等於父遊戲物件的位移。</span><span class="sxs-lookup"><span data-stu-id="caa99-482">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="caa99-483">這可以讓您的網格顯示數個計量，而這會讓您難以進行偵錯工具的處理。</span><span class="sxs-lookup"><span data-stu-id="caa99-483">This can make your meshes show up several meters away, which makes it hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="caa99-484">另請參閱</span><span class="sxs-lookup"><span data-stu-id="caa99-484">See also</span></span>

* [<span data-ttu-id="caa99-485">座標系統</span><span class="sxs-lookup"><span data-stu-id="caa99-485">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="caa99-486">DirectX 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="caa99-486">Spatial mapping in DirectX</span></span>](../develop/native/spatial-mapping-in-directx.md)
* [<span data-ttu-id="caa99-487">Unity 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="caa99-487">Spatial mapping in Unity</span></span>](../develop/unity/spatial-mapping-in-unity.md)
* [<span data-ttu-id="caa99-488">場景理解</span><span class="sxs-lookup"><span data-stu-id="caa99-488">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="caa99-489">空間位置掃描視覺效果</span><span class="sxs-lookup"><span data-stu-id="caa99-489">Room scan visualization</span></span>](room-scan-visualization.md)
* [<span data-ttu-id="caa99-490">空間音效設計</span><span class="sxs-lookup"><span data-stu-id="caa99-490">Spatial sound design</span></span>](spatial-sound-design.md)
* [<span data-ttu-id="caa99-491">案例研究 - 在實境中的的透視技術</span><span class="sxs-lookup"><span data-stu-id="caa99-491">Case study - Looking through holes in your reality</span></span>](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)