---
title: 空間對應
description: 空間對應提供在 HoloLens 周圍環境中實際表面的詳細標記法。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應、HoloLens、混合現實、表面重建、網格、混合現實耳機、windows mixed reality 耳機、虛擬實境耳機、HoloLens、MRTK、混合現實工具組、場景理解、世界網格、遮蔽、物理、流覽、表面觀察器、轉譯、網格處理
ms.openlocfilehash: 3268f25f86cdfea3aa1ae0b77c4fbeb9aa0ce1b9
ms.sourcegitcommit: 8f141a843bcfc57e1b18cc606292186b8ac72641
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/19/2021
ms.locfileid: "110196423"
---
# <a name="spatial-mapping"></a>空間對應

空間對應可在 HoloLens 的環境中提供真實世界表面的詳細表示，讓開發人員能夠建立令人信服的混合現實體驗。 藉由將真實世界與虛擬世界合併，應用程式可以讓全像是真實的。 應用程式也可以藉由提供熟悉的真實世界行為和互動，更自然地配合使用者期望。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a>裝置支援

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><strong>功能</strong></td>
        <td><a href="/hololens/hololens1-hardware"><strong>HoloLens (第 1 代)</strong></a></td>
        <td><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></td>
        <td><a href="../discover/immersive-headset-hardware-details.md"><strong>沉浸式頭戴裝置</strong></a></td>
    </tr>
     <tr>
        <td>空間對應</td>
        <td>✔️</td>
        <td>✔️</td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a>為什麼空間對應很重要？

空間對應可以讓使用者將物件放置在實際的表面上。 這有助於錨定使用者世界中的物件，並充分利用真實的深度提示。根據其他的全像全像遮蔽和真實世界物件來您的全像，有助於說服使用者這些全像是在空間中。 以空間浮動的全像移動空間或與使用者移動並不會覺得真實的。 可能的話，請將專案放在更舒適的位置。

在放置或移動全像移動 (使用投影出的方格) 時，將表面視覺化。 這可協助使用者知道其最適合放置全息的位置，並顯示他們嘗試放置全像全像的地方是否未對應。 如果使用者的角度太多，您可以向使用者「佈告欄專案」。

## <a name="conceptual-overview"></a>概念概觀

![涵蓋房間的網格表面](images/SurfaceReconstruction.jpg)<br>
*涵蓋房間的空間地圖網格範例*

空間對應所使用的兩種主要物件類型為「空間介面觀察者」和「空間介面」。

應用程式會提供具有一或多個周框磁片區的空間介面觀察器，以定義應用程式希望接收空間對應資料的空間區域。 針對上述每個磁片區，空間對應將會為應用程式提供一組空間表面。

這些磁片區可能是固定位置中的固定 (（以真實世界) 為基礎），或者它們可能會附加到 HoloLens (，但不會在透過環境) 移至 HoloLens 的情況下輪替。 每個空間介面都會以少量的空間描述真實世界表面，以連接到世界鎖定 [空間座標系統](coordinate-systems.md)的三角形網格表示。

當 HoloLens 收集有關環境的新資料，且發生環境變更時，空間介面會出現、消失及變更。

## <a name="spatial-awareness-design-concepts-demo"></a>空間感知設計概念示範

如果您想要看到空間感知設計概念的實際運作，請參閱下面 **的設計全像影像空間感知** 影片示範。 當您完成時，請繼續進行，以深入瞭解特定主題。

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Microsofts-Designing-Holograms-Spatial-Awareness-Chapter/player]

*這段影片取自「設計全像」應用程式 HoloLens 2 應用程式。下載並享有完整 [的體驗。](https://aka.ms/dhapp)*

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a>空間對應與場景的比較理解 WorldMesh

針對 HoloLens 2，可以使用 [場景理解 SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 設定) 查詢靜態版本的空間對應資料。 以下是存取空間對應資料的兩種方式之間的差異：
* 空間對應 API：
   * 有限範圍：適用于應用程式的空間對應資料，以有限大小的快取「反升」方式提供給使用者。
   * 透過 SurfacesChanged 事件提供變更網格區域的低延遲更新。
   * 依每個三立方計量參數的三角形所控制的詳細詳細資料層級。
* 場景理解 SDK：
   * 無限制範圍-提供查詢半徑內所有掃描的空間對應資料。
   * 提供空間對應資料的靜態快照集。 取得更新的空間對應資料需要對整個網格執行新的查詢。
   * RequestedMeshLevelOfDetail 設定所控制的一致詳細資料層級。

## <a name="what-influences-spatial-mapping-quality"></a>什麼會影響空間對應品質？

[這裡](/hololens/hololens-environment-considerations)詳述的數個因素可能會影響這些錯誤的頻率和嚴重性。  不過，您應該設計您的應用程式，讓使用者即使在空間對應資料中發生錯誤，也可以達成其目標。

## <a name="common-usage-scenarios"></a>常見使用案例

![一般空間對應使用案例的圖例：位置、遮蔽、物理和導覽](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空間對應讓應用程式有機會為使用者呈現自然且熟悉的互動形式;將您的電話放在桌上是什麼自然？

限制 (或更多的地理空間位置的位置。) 到表面上的任何空間位置選擇，都會提供從 3D () 點到 surface (上 2D) 點的自然對應。 這可減少使用者提供給應用程式所需的資訊量，讓使用者的互動速度更快、更容易且更精確。 這是因為「離離」不是我們用來與其他人或電腦實際通訊的內容。 當我們指向手指時，會指定方向，但不是距離。

其中一個重要的警告是，當應用程式從方向推斷距離 (例如，沿著使用者的注視方向 raycast，以找出最接近的空間介面) 時，這必須產生使用者可以可靠地預測的結果。 否則，使用者將會失去其控制的意義，而這可能很快就會很令人沮喪。 其中一個有助於進行這項作業的方法，就是進行多個 raycasts，而不是只有一個。 匯總結果應更平滑且更容易預測，較不容易影響暫時性的「極端」結果 (原因可能是因為光線通過小洞，或是達到使用者不知道) 的少量幾何。 您也可以在一段時間內執行匯總或平滑處理;例如，您可以限制每個全息圖的最大速度，與使用者的距離不同。 只要限制最小值和最大距離值也會有所説明，因此移動的全像影像也不會突然離開到距離，或損毀到使用者的臉部。

應用程式也可以使用表面的圖形和方向來引導全息圖放置。 全像椅子的椅子不應該穿透牆，而且即使是稍微不平均，也應該排清地面。 這類功能可能依賴物理衝突，而不是 raycasts，不過也適用類似的考慮。 如果要放置的全息圖案有許多小型多邊形，例如椅子上的腿，將這些多邊形的物理表示擴展至更寬且更平滑的位置，讓它們更能在沒有畫面的情況下滑出空間表面。

在極端的情況下，使用者輸入可以完全簡化，而空間介面可用來完全自動進行全像投影放置。 例如，應用程式可以在牆上的某處放置全像 light 切換，讓使用者按下。 有關可預測性的相同注意事項也適用于此處。如果使用者想要控制全息圖放置，但應用程式不一定會將影像放在其預期的位置 (如果燈光出現在使用者無法觸達) 的某個位置，則這會是令人沮喪的體驗。 它實際上可能更糟的是，自動放置需要使用者更正的時間，而不是只需要使用者永遠自行放置;由於預期自動放置 *應該* 會成功，因此手動更正會像是負擔一樣！

另請注意，應用程式使用空間介面進行放置的能力，主要取決於應用程式的 [掃描體驗](spatial-mapping.md#the-environment-scanning-experience)。 如果介面尚未掃描，則無法用於放置。 應用程式是由應用程式對使用者進行清楚的設定，讓他們可以協助掃描新的表面或選取新的位置。

在放置期間，對使用者的視覺效果意見反應最為重要。 使用者必須知道全像是以 [接地效果](spatial-mapping.md#visualization)最接近的表面為基礎的全像影像。 他們應該瞭解如何將其全息影像的移動限制 (例如，因為與另一個附近的表面) 發生衝突。 如果它們無法將全像放在目前的位置，則視覺效果的意見反應應該讓它清楚說明為何。 比方說，如果使用者想要將全像沙發的一半帶到牆中，則牆後方的沙發部分應該以生氣的色彩 pulsate。 相反地，如果應用程式在使用者可以看到真實世界表面的位置找不到空間介面，則應用程式應該將它清除。 在此區域中沒有明顯的接地效果，可能會達到這個目的。

### <a name="occlusion"></a>遮蔽

空間對應介面的主要用途之一，就是遮蔽全像影像。 這種簡單的行為會大幅影響全像全像的全像的全像投影，可協助建立 visceral 的意義，以真正理解與使用者相同的實體空間。

遮蔽也會提供資訊給使用者;當真實世界表面 pixels occluded 的全像影像時，這會提供額外的視覺效果意見反應，以提供給世界上該全像影像的空間位置。 相反地，遮蔽也可以常見 *隱藏* 使用者的資訊;遮蔽牆後方的全像投影可以直覺地減少視覺效果。 若要隱藏或顯示全像影像，使用者只需要移動自己的標頭。

遮蔽也可以用來根據熟悉的實體互動，對自然使用者介面的期望進行質數;如果影像是由表面 pixels occluded，就是因為表面是實心的，所以使用者應該預期全像影像會與該表面發生 *衝突* ，而不會通過它。

有時，不需要遮蔽全像影像。 如果使用者需要與全息圖互動，則他們需要查看它，即使是在真實世界表面上也一樣。 在這種情況下，在 pixels occluded (時，以不同的方式呈現這類全息圖，例如降低其亮度) 。 如此一來，使用者就能以視覺化的方式找出全像影像，但仍然知道它背後的東西。

### <a name="physics"></a>物理特性

使用物理模擬是另一種方式，可用來在使用者的實體空間中強調 *顯示* 全像影像。 當我的全像橡膠球從桌上走出來時，在樓層間彈跳，並在沙發下消失時，我可能很難相信它不存在。

物理模擬也讓應用程式有機會使用自然且熟悉的物理互動。 如果傢俱以適當的慣性和摩擦在地面之間滑動，則在地面上移動一小段的全像傢俱可能更容易。

若要產生實際的實體行為，您可能需要進行一些 [網格處理](spatial-mapping.md#mesh-processing) ，例如填滿孔洞、移除浮動 hallucinations 和平滑表面。

您也必須考慮應用程式的 [掃描體驗](spatial-mapping.md#the-environment-scanning-experience) 會如何影響其物理模擬。 首先，遺漏的表面將不會與任何值衝突;當橡膠球在 corridor 和已知世界結束時，會發生什麼事？ 其次，您必須決定是否要在一段時間後繼續回應環境中的變更。 在某些情況下，您會想要儘快回應;比方說，如果使用者使用門和傢俱作為內送羅馬箭號 tempest 的可移動 barricades。 但在其他情況下，您可能會想要忽略新的更新;如果您的狗決定坐在播放軌的中間，讓您的全像 racetrack 在地面上推動您的全像運動車，可能突然不太有趣。

### <a name="navigation"></a>導覽

應用程式可以使用空間對應資料來授與全息字元 (或代理程式) 能夠以真實人員的相同方式流覽真實世界。 這有助於加強全像攝影字元的存在，方法是將其限制為與使用者和朋友的相同自然、熟悉的行為集合。

流覽功能也可能對使用者很有説明。 一旦在指定的區域內建了導覽對應，就可以共用它，為不熟悉該位置的新使用者提供全像方向的指示。 此對應的設計目的是為了協助讓地下的流量順暢地流動，或避免發生在結構網站等危險位置的意外情況。

執行導覽功能時所牽涉到的關鍵技術挑戰，將會對 walkable 表面進行可靠的偵測， (人類不會逐步解說資料表！ ) 和適當地調整環境中的變更 (人類不會逐步解說 ) 。 網格可能需要進行一些 [處理](spatial-mapping.md#mesh-processing) ，才能用於路徑規劃和依虛擬字元進行導覽。 將網格平滑化並移除 hallucinations，可能有助於避免字元變成停滯。 您也可能想要大幅簡化網格，以加速您的字元路徑規劃和導覽計算。 這些挑戰在開發影片遊戲技術方面已有很大的説明，而且有許多關於這些主題的可用研究文獻。

Unity 中的內建 NavMesh 功能無法搭配空間對應介面使用。 這是因為在應用程式啟動之前不知道空間對應介面，但必須事先從來源資產產生 NavMesh 資料檔案。 另請注意，空間對應系統將不會提供離使用者目前位置更 [遠的表面資訊](spatial-mapping.md#the-environment-scanning-experience) 。 因此，如果應用程式要建立大型區域的地圖，就必須「記住」。

### <a name="visualization"></a>視覺效果

大部分的時間都適合讓空間表面變成不可見;為了將視覺效果雜亂降至最低，並讓真實世界說出本身。 不過，有時候直接視覺化空間對應介面會很有用，儘管它們的真實世界對應專案都是可見的。

例如，當使用者嘗試將全像放在表面上時， (將全像是放在牆上的全像) ，就可以藉由將陰影轉換成表面，來「地面」「地面」。 這樣可讓使用者更清楚地瞭解全像全像全像是全像是全像全像是全像是全像是 這也是在使用者認可變更之前，以視覺化方式「預覽」變更的一般作法範例。

藉由視覺化介面，應用程式可以與使用者共用環境的理解。 例如，全像攝影板的遊戲可將其識別為「資料表」的水準表面視覺化，讓使用者知道他們應該前往哪裡進行互動。

視覺化介面可以用來顯示隱藏于視野中的使用者附近空間。 這可能會讓使用者能夠存取其廚房 (，以及其所包含的全像全像的全像房間) 。

空間對應所提供的介面網格可能不是特別的「清除」。 請務必適當地將它們視覺化。 傳統的光源計算可能會以視覺化方式反白顯示 surface 法線中的錯誤，而「清理」紋理則投射在表面上可能有助於提供整齊的外觀。 您也可以在呈現介面之前，進行 [網格處理](spatial-mapping.md#mesh-processing) 以改善網格屬性。

> [!NOTE]
> HoloLens 2 會採用新的 [場景理解運行](scene-understanding.md)時間，為混合的現實開發人員提供結構化、高階的環境標記法，其設計目的是要簡化放置、遮蔽、物理和流覽的執行。

## <a name="using-the-surface-observer"></a>使用介面觀察者

空間對應的起點是介面觀察者。 程式流程如下所示：
* 建立 surface observer 物件
   * 提供一個或多個空間磁片區，以定義應用程式希望接收空間對應資料的相關區域。 空間磁片區只是定義空間區域（例如球體或方塊）的圖形。
   * 使用具有世界鎖定空間座標系統的空間磁片區，以識別實體世界的固定區域。
   * 使用空間磁片區，以主體鎖定的空間座標系統更新每個畫面格，以識別移動 (但不會向使用者旋轉) 的空間區域。
   * 這些空間磁片區稍後可能會變更，因為應用程式或使用者的狀態會變更。
* 使用輪詢或通知取得空間介面的相關資訊
   * 您可以隨時「輪詢」空間介面狀態的表面觀察器。 相反地，您可能會註冊介面觀察者的「介面變更」事件，這會在空間表面變更時通知應用程式。
   * 如果是動態空間磁片區（例如，視圖的分隔或主體鎖定的磁片區），則應用程式必須藉由設定感興趣的區域，然後取得目前的空間介面集，來輪詢每個畫面格的變更。
   * 針對靜態磁片區（例如涵蓋單一房間的全球鎖定 cube），應用程式可能會註冊「表面變更」事件，以在該磁片區內的空間表面變更時收到通知。
* 進程介面變更
   * 反覆運算提供的空間介面集。
   * 將空間表面分類為已新增、變更或移除。
   * 針對每個新增或變更的空間介面，如果適當地提交非同步要求，以在所需的詳細資料層級上接收代表 surface 目前狀態的更新網格。
* 處理非同步網狀要求 () 的下列各節中有更多詳細資料。

## <a name="mesh-caching"></a>網格快取

空間介面會以密集三角形網格來表示。 儲存、轉譯和處理這些網格可以耗用大量的計算和儲存體資源。 因此，每個應用程式都應該採用適合其需求的網格快取配置，以將用於網格處理和儲存的資源降至最低。 此配置應決定要保留哪些網格和要捨棄哪些，以及何時更新每個空間介面的網格。

這裡討論的許多考慮都會直接通知應用程式應該如何處理網格快取。 您應該考慮使用者在環境中的移動方式、何時會觀察到不同的介面，以及何時應捕捉環境中的變更。

當解釋介面觀察器所提供的「介面變更」事件時，基本網格快取邏輯如下所示：
* 如果應用程式看到先前未看到的空間介面識別碼，則應該將它視為新的空間介面。
* 如果應用程式看到具有已知識別碼但有新更新時間的空間介面，則應該將其視為更新的空間介面。
* 如果應用程式不再看到具有已知識別碼的空間介面，則應該將其視為已移除的空間介面。

接著，每個應用程式都必須進行下列選擇：
* 針對新的空間介面，是否應要求網格？
   * 通常應該針對新的空間介面立即要求網格，這可能會為使用者提供實用的新資訊。
   * 不過，在使用者附近和前方的新空間介面應該具有優先權，且應先要求其網格。
   * 如果不需要新的網狀，例如應用程式已永久或暫時「凍結」其環境模型，則不應要求。
* 針對更新的空間介面，是否應要求網格？
   * 已更新使用者附近和前方的空間表面應獲得優先考慮，而且應該先要求其網格。
   * 您也可以在新表面上給予較高的優先順序，而不是更新的表面，尤其是在掃描體驗期間。
   * 若要限制處理成本，應用程式可能會想要對其處理空間表面更新的速率進行節流處理。
   * 可能會推斷空間介面的變更是次要的，例如，如果表面的界限很小，在此情況下，更新可能不太重要而無法處理。
   * 在使用者感興趣的目前區域以外的空間介面更新可能完全被忽略，不過在此情況下，修改介面觀察器所使用的空間界限磁片區可能更有效率。
* 針對已移除的空間介面，是否應捨棄網格？
   * 通常應該針對移除的空間表面立即捨棄網格，讓全像遮蔽維持正確。
   * 但是，如果應用程式有理由認為空間介面會根據使用者體驗) 的設計而 (重新出現，則比起捨棄其網格並重新建立它可能更有效率。
   * 如果應用程式正在建立使用者環境的大規模模型，則可能完全不想要捨棄任何網格。 不過，它仍然需要限制資源使用量，可能是因為空間表面消失而將網格幕後處理至磁片。
   * 在空間介面產生期間，有些相當罕見的事件可能會導致空間介面由類似位置中的新空間介面取代，但使用不同的識別碼。 因此，選擇不捨棄已移除表面的應用程式，應該要注意的是，不會有多個高度重迭的空間介面網格涵蓋相同的位置。
* 是否應該針對任何其他空間表面捨棄網格？
   * 即使空間介面存在，如果該介面不再適用于使用者的體驗，則應該將它捨棄。 例如，如果應用程式「以替代的虛擬空間取代」門口另一端的房間，則該房間內的空間表面將不再重要。

以下是使用空間和時態性滯後的範例網格快取策略：
* 假設有一個應用程式想要使用在使用者看起來類似的錐形空間磁片區，然後在使用者看起來和四處四處討論。
* 空間介面可能會暫時從此磁片區消失，因為使用者從表面看起來不到它的表面或步驟 .。。請稍後再回頭查看或移動更近的時間。 在此情況下，捨棄並重新建立此介面的網格表示許多重複的 processings。
* 為了減少已處理的變更數目，應用程式會使用兩個空間介面觀察器，其中一個是包含在另一個中。 較大的音量是球形，並遵循使用者「延遲」;只有在必要時才會移動，以確保其中心是在使用者的2.0 計量內。
* 新的和更新的空間介面網格一律會從較小的內部介面觀察器進行處理，但是網格會被快取，直到從較大的外部介面觀察器消失為止。 這可讓應用程式避免因本機使用者移動而處理許多多餘的變更。
* 由於空間介面可能會因為追蹤遺失而暫時消失，因此應用程式也會在追蹤遺失期間延遲捨棄移除的空間表面。
* 一般而言，應用程式應該評估減少更新處理與記憶體使用量增加之間的取捨，以判斷其理想的快取策略。

## <a name="rendering"></a>轉譯

空間對應網格通常用於轉譯的主要方式有三種：
* 介面視覺效果
   * 直接視覺化空間介面通常很有用。 例如，將「陰影」從物件轉換成空間介面，可在將影像放在表面上時，為使用者提供實用的視覺效果意見反應。
   * 有一點要注意的是，空間網格與3D 演出者可能建立的網格類型不同。 三角形拓撲不會像人類建立的拓撲一樣成為「乾淨」，而網格將會因 [各種錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality)而受到影響。
   * 若要建立美觀的視覺效果美觀，您可能會想要進行一些 [網格處理](spatial-mapping.md#mesh-processing)，例如填滿孔或平滑表面法線。 您也可能想要使用著色器將演出者設計的材質投影到您的網狀架構，而不是直接視覺化網格拓朴和法線。
* 適用于真實世界表面的遮蔽全息
   * 空間介面可以在深度專用階段中轉譯，只會影響 [深度緩衝區](/windows/win32/direct3d9/depth-buffers) ，而不會影響色彩呈現目標。
   * 這會質數深度緩衝區，以遮蔽後續呈現空間介面背後的全像投影。 確切的全像遮蔽，可增強全像是在使用者的實體空間內真正存在的全像的意義。
   * 若要啟用深度呈現，請更新您的 blend 狀態，以將所有色彩呈現目標的 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 設為零。
* 用於修改實際表面的全像 pixels occluded 影像外觀
   * Pixels occluded 時，通常會隱藏呈現的幾何。 這是藉由將深度樣板狀態中的深度函 [式](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 設定為「小於或等於」來達成，這會使幾何只有在比先前轉譯的幾何 **更接近** 相機的位置才可見。
   * 不過，將某些幾何保持 pixels occluded，以及在 pixels occluded 為提供視覺回饋給使用者的方式時修改其外觀可能會很有用。 例如，這可讓應用程式向使用者顯示物件的位置，同時讓它清楚地顯示在真實世界表面的背後。
   * 若要達到此目的，請使用不同的著色器，以建立所需的「pixels occluded」外觀來第二次轉譯幾何。 第二次轉譯幾何之前，請對您的 [深度樣板狀態](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)進行兩個變更。 首先，將深度函式設定為 [大於或等於]，如此一來，就只會顯示幾何與所有先前轉譯之幾何 **更遠** 的位置。 其次，將 DepthWriteMask 設定為零，如此就不會修改深度緩衝區， (深度緩衝區應繼續表示 **最接近** 相機) 的幾何深度。

轉譯空間對應網格時，[效能](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)是很重要的考慮。 以下是轉譯空間對應網格專用的一些轉譯效能技術：
* 調整三角形密度
   * 當您從介面觀察器要求空間介面網格時，請要求可滿足您需求的最小的三角形網格密度。
   * 視介面與使用者的距離，以及其與使用者體驗的關聯性而定，可能會有意義地依據介面變化三角形密度。
   * 減少三角形計數將會降低 GPU 上的記憶體使用量和頂點處理成本，但不會影響圖元處理成本。
* 使用截錐剔除
   * 如果您不是在目前的顯示中，則會將 [已被剔除] 剔除略過繪圖物件。 這可降低 CPU 和 GPU 的處理成本。
   * 由於會對每個網狀架構執行剔除，而空間介面可能很大，因此將每個空間介面網格分成較小的區塊，可能會導致更有效率的剔除 (在) 中呈現較少的三角形。 但是，您擁有的網格越多，您必須進行的繪製呼叫越多，就會增加 CPU 成本。 在極端情況下，以錐剔除計算本身甚至可以有可測量的 CPU 成本。
* 調整轉譯順序
   * 空間表面通常很大，因為它們代表使用者在周圍的整個環境。 GPU 上的圖元處理成本可能很高，特別是在有多個可見幾何的層級 (包括空間表面和其他全像) 。 在此情況下，最接近使用者的圖層將會進一步遮蔽任何層級，因此任何花費在更遠距離圖層的 GPU 時間都不會浪費。
   * 若要減少 GPU 上的這項重複工作，最好先將不透明的表面轉譯 (更接近的介面，最後) 。 「不透明」是指在 [深度樣板狀態](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)中，DepthWriteMask 設定為一個的表面。 轉譯最接近的介面時，它們會將深度緩衝區質數，讓 GPU 上的圖元處理器可以有效率地略過更遠的表面。

## <a name="mesh-processing"></a>網格處理

應用程式可能會想要在空間介面網格上進行 [各種作業](spatial-mapping.md#mesh-processing) ，以符合其需求。 每個空間介面網格所提供的索引和頂點資料，會使用與用來呈現所有新式轉譯 Api 中三角形網格的 [頂點和索引緩衝區](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 相同的熟悉版面配置。 不過，有一個要注意的關鍵事實是，空間對應三角形有 **正面的纏繞順序**。 每個三角形都是以網格的索引緩衝區中的三個頂點索引來表示，而這些索引將會在從 **前端** 看到三角形時，以 **順** 向順序識別三角形的頂點。 空間介面網格的前端 (或外) ，會與您預期的正面 (可見的真實世界表面) 相同。

如果介面觀察器所提供的最粗略三角形密度仍能力不佳粗略，則應用程式應該只進行網格簡化，這項工作的計算成本很高，而且已經由執行時間執行，以產生各種提供的詳細資料層級。

由於每個介面觀察者都可以提供多個未連接的空間介面，因此有些應用程式可能會想要彼此裁剪這些空間介面網格，然後將它們 zipper 在一起。 一般情況下，裁剪步驟是必要的，因為鄰近的空間介面網格通常會稍微重迭。

## <a name="raycasting-and-collision"></a>Raycasting 和碰撞

為了讓物理 API (例如 [Havok](https://www.havok.com/)) 為應用程式提供空間介面的 raycasting 和碰撞功能，應用程式必須提供空間介面網格給物理 api。 用於物理的網格通常具有下列屬性：
* 它們只包含少量的三角形。 物理運算比轉譯作業更耗費計算。
* 它們是「水緊密型」。 預期為穩固的表面不應該有小洞;即使漏洞太小而無法顯示，也會造成問題。
* 它們會轉換成凸 hulls。 凸 hulls 有很少的多邊形，而且沒有孔洞，而且比原始三角形網格更能有效率地處理這些空間。

針對空間介面進行 raycasts 時，請記住，這些表面通常很複雜，雜亂的圖形幾乎不會有很大的細節，就像您的辦公桌一樣！ 這表示單一 raycast 通常不足以提供您足夠的資訊，讓您瞭解表面的形狀，以及附近的空白空間的形狀。 在社區域內執行許多 raycasts，以及使用匯總結果來更可靠地瞭解介面，通常是個不錯的主意。 例如，使用10個 raycasts 的平均值來引導表面上的全像影像放置，將會產生更平滑且較不只使用單一 raycast 的「抖動」結果。

不過，請記住，每個 raycast 可能會有較高的計算成本。 視您的使用案例而定，您應該權衡額外 raycasts 的計算成本 (完成每個) 畫面格的 [計算成本，以平滑](spatial-mapping.md#mesh-processing) 和移除空間介面中的漏洞 (在空間網格更新) 時完成。

## <a name="the-environment-scanning-experience"></a>環境掃描體驗

使用空間對應的每個應用程式都應該考慮提供「掃描體驗」;應用程式會透過此程式引導使用者掃描應用程式正常運作所需的表面。

![掃描範例](images/sr-mixedworld-140429-8pm-00068-1000px.png)<br>
*掃描範例*

這種掃描體驗的本質可能會隨著每個應用程式的需求而有很大的差異，但有兩個主要原則應該引導其設計。

首先， **與使用者進行清楚的通訊是主要考慮**。 使用者應該一律留意是否符合應用程式的需求。 當它們不符合時，就應該立即清楚清楚使用者的原因，而且應該很快就會採取適當的動作。

其次， **應用程式應該嘗試在效率與可靠性之間取得平衡**。 如果可以 **可靠地** 這麼做，應用程式應該會自動分析空間對應資料，以節省使用者的時間。 如果無法可靠地這麼做，應用程式應該改為讓使用者快速提供應用程式所需的其他資訊。

為了協助設計正確的掃描體驗，請考慮下列哪一個可能適用于您的應用程式：

* **沒有掃描體驗**
   * 應用程式在沒有任何引導式掃描體驗的情況下可以完美運作;它會瞭解在自然使用者移動過程中觀察到的表面。
   * 例如，讓使用者在具有全像油漆油漆的表面上繪製的應用程式，只需要知道使用者目前可見的表面。
   * 如果環境是使用者已使用 HoloLens 花了很多時間，則可能會掃描環境。
   * 請記住，空間對應所使用的相機只能在使用者前方看到 3.1 m，因此空間對應將不會知道任何較遠的表面，除非使用者從較接近的距離觀察到它們。
   * 因此，使用者瞭解哪些表面已經過掃描，應用程式應該提供視覺效果回饋給這個效果，例如，將虛擬遮蔽轉換成掃描的表面，可能有助於使用者將影像放在這些表面上。
   * 在此情況下，應該將每個畫面格的空間介面觀察器界限磁片區更新為主體鎖定的 [空間座標系統](coordinate-systems.md)，使其符合使用者的限制。

* **尋找適當的位置**
   * 應用程式的設計可用於具有特定需求的位置。
   * 例如，應用程式可能需要使用者的空白區域，讓他們可以安全地實務 kung-fu。
   * 應用程式應該將任何特定需求傳達給使用者，並以清楚的視覺效果回饋來強化。
   * 在此範例中，應用程式應該將所需空白區域的範圍視覺化，並以視覺化方式醒目提示此區域內任何不想要的物件是否存在。
   * 在此情況下，空間介面觀察者的周框磁片區應在選擇的位置使用世界鎖定的 [空間座標系統](coordinate-systems.md) 。

* **尋找適合的表面設定**
   * 應用程式可能需要特定的介面設定，例如兩個大型、平坦的牆，以建立一個全像的鏡像廳。
   * 在這種情況下，應用程式將需要分析空間對應所提供的介面，以偵測適當的表面，並將使用者導向至這些介面。
   * 如果應用程式的介面分析不可靠，則使用者應該有一個 [回復] 選項。 例如，如果應用程式不正確地將門口識別為平面，則使用者需要簡單的方法來修正此錯誤。

* **掃描部分環境**
   * 應用程式可能會想要根據使用者的指示，只捕獲部分的環境。
   * 例如，應用程式會掃描房間內的一部分，讓使用者可以針對想要銷售的傢俱張貼全像已分類的廣告。
   * 在此情況下，應用程式應該在使用者掃描期間，于使用者觀察到的區域內，捕捉空間對應資料。

* **掃描整個聊天室**
   * 應用程式可能需要掃描目前房間中的所有表面，包括使用者背後的所有表面。
   * 例如，遊戲可能會將使用者置於 Gulliver 的角色中，從數百個從所有方向接近的微小 Lilliputians siege。
   * 在這種情況下，應用程式必須判斷目前空間中已掃描的表面數量，並指示使用者的注視填滿顯著的間隙。
   * 此程式的關鍵是提供視覺回饋，讓使用者清楚知道尚未掃描哪些表面。 例如，應用程式可以使用以 [距離為基礎的霧化](/windows/win32/direct3d9/fog-formulas) ，以視覺方式反白顯示空間對應介面未涵蓋的區域。

* **取得環境的初始快照集**
   * 在取得初始「快照集」之後，應用程式可能會想要忽略環境中的所有變更。
   * 這可能適用于避免與環境的初始狀態緊密結合的使用者建立資料中斷。
   * 在此情況下，應用程式應該在掃描完成後，以初始狀態建立空間對應資料的複本。
   * 如果環境仍能正確地 pixels occluded 全像影像，應用程式應該會繼續接收空間對應資料的更新。
   * 空間對應資料的持續更新也可讓您視覺化已發生的任何變更，將環境的先前與目前狀態之間的差異向使用者闡明。

* **採用使用者起始的環境快照集**
   * 應用程式可能只會在使用者指示時，想要回應環境變更。
   * 例如，使用者可以在不同的時間捕捉其姿勢，藉以建立多個「friend」的「statues」。

* **允許使用者變更環境**
   * 應用程式可能設計為即時回應使用者環境中所做的任何變更。
   * 例如，使用者繪圖 curtain 可能會觸發「場景變更」，以進行另一端的全像 play。

* **引導使用者避免空間對應資料中的錯誤**
   * 應用程式可能會想要在掃描其環境時，為使用者提供指引。
   * 這可協助使用者避免 [空間對應資料中](spatial-mapping.md#what-influences-spatial-mapping-quality)發生特定類型的錯誤，例如，離開 sunlit 視窗或鏡像。

有一個要注意的額外詳細資料，是空間對應資料的「範圍」不是無限的。 雖然空間對應確實會建立大量的永久資料庫，但它只會讓使用者以有限大小的「反升」方式提供資料給應用程式。 如果您從長 corridor 的開頭開始，並從一開始就到達足夠的位置，則最後的空間表面將會消失。 您可以在應用程式中從可用空間對應資料消失之後，將這些表面快取，藉以減輕此問題。

## <a name="mesh-processing"></a>網格處理

它可能有助於偵測介面中常見的錯誤類型，並視需要篩選、移除或修改空間對應資料。

請記住，空間對應資料的預期會盡可能忠實呈現到真實世界的表面，因此，您所套用的任何處理都會將您的介面從「真」進一步改變。

以下是一些您可能會覺得有用的不同網格處理類型範例：

* **孔填滿**
   * 如果有深色材質的小型物件無法掃描，它就會在周圍表面留下洞。
   * 孔會影響遮蔽：在被視為不透明的真實世界表面中，可以看到「全像」。
   * 漏洞會影響 raycasts：如果您使用 raycasts 來協助使用者與表面互動，則這些光線可能不需要通過漏洞。 其中一個緩和措施是使用多個 raycasts 的組合，其中涵蓋適當大小的區域。 這可讓您篩選「極端的」結果，如此一來即使某個 raycast 通過小洞，匯總結果仍會有效。 不過，這種方法會產生計算成本。
   * 孔會影響物理衝突：物理模擬所控制的物件可能會在樓層中下降，並會遺失。
   * 您可以在表面網格中演算法填滿這類漏洞。 不過，您必須調整演算法，讓「真實漏洞」（例如 windows 和門口）不會被填入。 可能很難可靠地區分「真實漏洞」與「虛漏洞」，因此您必須試驗不同的啟發學習法，例如「大小」和「界限圖形」。

* **Hallucination 移除**
   * 反射、亮燈和移動物件可能會將小型的延遲 ' hallucinations ' 浮在中。
   * Hallucinations 會影響遮蔽： Hallucinations 可能會顯示為在前方移動的深色圖形，以及遮蔽其他的全像投影。
   * Hallucinations 會影響 raycasts：如果您使用 raycasts 來協助使用者與介面互動，則這些光線可能會叫用 hallucination 而非其背後的表面。 和漏洞一樣，有一個緩和措施是使用許多 raycasts，而不是單一 raycast，但同樣地，這會產生計算成本。
   * Hallucinations 會影響物理衝突：物理模擬所控制的物件可能會停滯于 hallucination，而且無法在看似清楚的空間區域內移動。
   * 您可以從介面網格篩選這類 hallucinations。 不過，如同漏洞，您將需要調整演算法，如此一來，就不會移除實際的小型物件，例如燈光表示和大門把手。

* **平滑處理**
   * 空間對應可能會傳回看似粗略或「雜訊」的表面，相較于其真實世界的對應專案。
   * 平滑度會影響物理衝突：如果地面是粗略的，則實際模擬的高爾夫球球可能無法順暢地在直線之間進行滾動。
   * 平滑會影響轉譯：如果介面是直接視覺化的，則粗略表面法線可能會影響其外觀並中斷「乾淨」外觀。 您可以在用來呈現介面的著色器中使用適當的光源和紋理來緩和這個問題。
   * 您可以將介面網格中的粗糙度平滑。 不過，這可能會從對應的真實世界表面中往外推出介面。 若要產生準確的全像遮蔽，以及讓使用者可以與全像攝影表面進行精確且可預測的互動，請務必維持密切的對應。
   * 如果只需要表面變更，可能就足以在不變更頂點位置的情況下平滑頂點法線。

* **平面尋找**
   * 應用程式可能會想要在空間對應所提供的表面上執行許多形式的分析。
   * 一個簡單的範例是「平面尋找」;識別表面的系結、大部分的平面區域。
   * 平面區域可用來當做全像工作表面，也就是可由應用程式自動放置全息內容的區域。
   * 平面區域可以限制使用者介面，以引導使用者與最符合其需求的表面互動。
   * 平面區域可在真實世界中使用，適用于多功能物件（例如 LCD 螢幕、表格或白板）。
   * 平面區域可以定義播放區域，形成影片遊戲等級的基礎。
   * 平面區域可協助虛擬專員流覽真實世界，方法是找出真實人員可能進行的範圍。

## <a name="prototyping-and-debugging"></a>原型設計和調試

### <a name="useful-tools"></a>有用的工具

* [HoloLens 模擬器](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md)可以用來開發使用空間對應的應用程式，而不需要存取實體 HoloLens。 它可讓您在實際的環境中，使用您的應用程式通常會取用的所有資料（包括 HoloLens 動作、空間座標系統和空間對應網格）來模擬 HoloLens 上的即時會話。 這可以用來提供可靠、可重複的輸入，這對您的程式碼所做的變更和評估程式碼的變更可能很有用。
* 若要重現案例，請從即時 HoloLens 的網路上抓取空間對應資料，然後將它儲存至磁片，並在稍後的偵測會話中重複使用。
* [Windows 裝置入口網站3d 視圖](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view)會提供一種方式，讓您查看目前可透過空間對應系統使用的所有空間表面。 這會針對應用程式內的空間表面提供比較的基礎例如，您可以輕鬆地分辨是否有任何空間表面遺失或顯示在錯誤的位置。

### <a name="general-prototyping-guidance"></a>一般原型設計指導方針

* 因為空間對應資料中的 [錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality) 可能會對您的使用者體驗造成強烈影響，所以建議您在各種環境中測試您的應用程式。
* 不要習慣在相同位置（例如您的辦公桌）進行永遠測試的習慣。 請務必在不同位置、圖形、大小和材質的各種表面上進行測試。
* 同樣地，雖然綜合或記錄的資料很適合用來進行偵錯工具，但不太依賴相同的測試案例。 這可能會延遲尋找更多測試較早所攔截到的重要問題。
* 使用實際的 (和理想的 uncoached) 使用者進行測試是個不錯的主意，因為它們可能不會像您一樣使用 HoloLens 或您的應用程式。 事實上，這可能會令人驚訝的是，人們的行為、知識和假設可以是什麼？

## <a name="troubleshooting"></a>疑難排解

* 為了讓介面網格正確源，每個 GameObject 都必須在使用中，然後才會將它傳送至 SurfaceObserver，以建立其網格。 否則，網格會顯示在您的空間中，但以怪角度旋轉。
* 執行與 SurfaceObserver 通訊之腳本的 GameObject 必須設定為來源。 否則，您建立並傳送給 SurfaceObserver 的所有 Gameobject 都有其格線，其位移等於父遊戲物件的位移。 這可以讓您的網格顯示數個計量，而這會讓您難以進行偵錯工具的處理。

## <a name="see-also"></a>另請參閱

* [座標系統](coordinate-systems.md)
* [DirectX 中的空間對應](../develop/native/spatial-mapping-in-directx.md)
* [Unity 中的空間對應](../develop/unity/spatial-mapping-in-unity.md)
* [場景理解](scene-understanding.md)
* [空間位置掃描視覺效果](room-scan-visualization.md)
* [空間音效設計](spatial-sound-design.md)
* [案例研究 - 在實境中的的透視技術](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)